/*	Path for this file is:	/usr/local/etc/httpd/cgi-bin/pagelab/charles/CalcTheta	My stupid reminders on how to use XS:	To start, generate folder and support files     : h2xs -A -n MyModuleName	Insert code after MODULE and PACKAGE keywords:	    double		simplePower(prob, power)			double prob			double power						PREINT:			can define variables in here						CODE:			blah blah blah (c goes here)			RETVAL = blah (what will be returned)			OUTPUT:			RETVAL	Move to directory with .xs file and execute		: perl Makefile.PL	At this point, you may need to clean up Makefile:		Check and see if makefile has any lines		refering to ".AppleDouble". If so, comment them		out, with the exception of:			Makefile.PL DIR=.AppleDouble \			which should just have ".AppleDouble" deleted.	Then execute									: make -s	Find the #!@%@ .so file. It was burried in		: blib/arch/auto/MyModuleName	Make a symlink to it in the /MyModuleName folder	Add /MyModuleName to @INC EARLY in the perl code:		push @INC, "fullPathHere/MyModuleName";	Designate the module at the top of the code     : use MyModuleName;*/#ifdef __cplusplusextern "C" {#endif#include "EXTERN.h"#include "perl.h"#include "XSUB.h"#ifdef __cplusplus}#endif/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *//* XS Interface Section */MODULE = CalcTheta		PACKAGE = CalcTheta		PROTOTYPES: ENABLEdoublefindLOD(markerA, markerB)	char*	markerA	char*	markerB		PREINIT:	int len, i;	double a1, a2, a3, a4, T, linked, unlinked;	char a,b;		CODE:	len = strlen(markerA);	// Need to verify that A and B have the same length. How to return from middle of code??		/* This code was originally written by Helen Skaletsky in Perl */	/* She adapted it from: Jones HB. Pairwise analysis of radiation hybrid mapping data	*/	/*						Ann. Hum. Genet. (1996). 60 351-357								*/	a1 = a2 = a3 = a4 = T = 0;	for (i = 0; i < len; i++) {		a = markerA[i];		b = markerB[i];		if ( a == '1' && b == '1' )	a1++;		if ( a == '1' && b == '0' )	a2++;		if ( a == '0' && b == '1' )	a3++;		if ( a == '0' && b == '0' )	a4++;	}	T = a1 + a2 + a3 + a4;					// Number of pairs with no ambiquities	if (a1 == 0) a1 = 0.01;	if (a2 == 0) a2 = 0.01;	if (a3 == 0) a3 = 0.01;	if (a4 == 0) a4 = 0.01;	linked	= a1 * log(a1/T) + a2 * log(a2/T) + a3 * log(a3/T) + a4 * log(a4/T);	T *= T;	unlinked=	a1 * log((a1+a2)*(a1+a3)/T) + a2 * log((a1+a2)*(a2+a4)/T) + 				a3 * log((a1+a3)*(a3+a4)/T) + a4 * log((a3+a4)*(a2+a4)/T);		RETVAL = (linked - unlinked)/log(10);	OUTPUT:	RETVAL	doublefindTheta(markerA, markerB)	char*	markerA	char*	markerB		PREINIT:	int len, i;	double rab, rba, ra, rb, rra, rrb, ta, tb, T, denom;	char a,b;		CODE:	len = strlen(markerA);	// Need to verify that A and B have the same lenght. How to return from middle of code??		/* This code was originally written by Helen Skaletsky in Perl */	/* She adapted it from: Jones HB. Pairwise analysis of radiation hybrid mapping data	*/	/*						Ann. Hum. Genet. (1996). 60 351-357								*/	rab = rba = ra = rb = ta = tb = T = 0;	for (i = 0; i < len; i++) {		a = markerA[i];		b = markerB[i];		if ( a == '1' && b == '0' )	rab++;	// Discrepancy between the two markers		if ( a == '0' && b == '1' )	rba++;		if ( a == '1' )				ra++;	// Hybrid is positive		if ( b == '1' )				rb++;		if ( a != '2')				ta++;	// Hybrid is not ambiguous		if ( b != '2')				tb++;		if ( a != '2' && b != '2')	T++;	// Both markers were not ambiguous for the hybrid	}	if ((ta == 0) || (tb == 0)) {		denom = 0;	} else {		rra = ra/ta; rrb = rb/tb;		denom = T * (rra + rrb - rra*rrb*2);	}	//	printf("rab = %f + rba = %f / denom = %f,   ", rab, rba, denom);	if (denom == 0) {		RETVAL = 5.0;						// Safety in case denominator = 0	} else {		RETVAL = (rab + rba) / denom;	}	OUTPUT:	RETVAL
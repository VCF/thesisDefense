/* * This file was generated automatically by xsubpp version 1.9507 from the  * contents of Probability.xs. Do not edit this file, edit Probability.xs instead. * *	ANY CHANGES MADE HERE WILL BE LOST!  * */#line 1 "Probability.xs"/*	My stupid reminders on how to use XS:	Move to directory with .xs file and execute		: perl Makefile.PL	Then execute									: make -s	Find the #!@%@ .so file. It was burried in		: blib/arch/auto/Probability	Move a copy to the /Probability folder	Add /Probability to @INC in the perl code. That's it!	Staffa path for this file is:	/usr/local/etc/httpd/cgi-bin/pagelab/charles/Probability*/#ifdef __cplusplusextern "C" {#endif#include "EXTERN.h"#include "perl.h"#include "XSUB.h"#include <stdio.h>#include <string.h>#include <stdlib.h>#include <math.h>#include <ctype.h>#ifdef __cplusplus}#endif#define	MAXHYB	250				// Maximum expected number of hybrids#define	MAXAMB	10				// Maximum number of ambiguities allowed by program (memory and time conservation)/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */struct ambigClass {	int					hybrids[4];	// The number of hybrids that have AB,A0,B0 and 00 marker content	int					members;	// Number of instances of this score	struct ambigClass*	high;		// Pointing to a member higher than it	struct ambigClass*	low;		// Pointing to a member lower than it	double				score;		// A score calulated from hybrids	double				choices;	// The number of ways this structure could have occured};typedef struct ambigClass ambigClass;/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */struct modScore {	char*				model;		// the name of the model	struct modScore*	high;		// Pointing to a member higher than it	struct modScore*	low;		// Pointing to a member lower than it	struct modScore*	root;		// Pointing to the member it derived from (will be higher)	double				lod;		// the lod score	double				lodDev;		// the standard deviation of the lod score	double				dist;		// the distance	double				distDev;	// the standard deviation of the distance	int					isUnlinked;	// Boolean indicating whether the model is unlinked (invariant) or not};typedef struct modScore modScore;/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */typedef struct {	char*	model[2];		// The name of the model (need two for the two orientations)	int		numDist;		// The number of distance values in the statistic	int		maxDist;		// The maximum distance (index) to be considered	int		keepDist;		// Disregard distances with index values greater than this	int		orient;			// The number of orientations for the model	int		isUnlinked;		// Boolean indicating whether the model is unlinked (invariant) or not	double	dist[100];		// The distance values	double	prob[2][4][100];// Probabilities for AB, A0, B0 and 00, in both orientations} statistic;/* - - - - - - - - Start  Prototypes - - - - - - - - */ double		findScore		(int* ambs);statistic*	makestat		(char* n, int el, char* d, char* AB, char* An, char* Bn, char* nn);void		findVariants	(char* markerA, char* markerB);ambigClass*	newAC			(void);void		addAC			(ambigClass* ac, int* hy, double sc);void		setAC			(ambigClass* ac, int* hy, double sc);/* - - - - - - - - Finish Prototypes - - - - - - - - */ static intnot_here(s)char *s;{    croak("%s not implemented on this architecture", s);    return -1;}static doubleconstant(name, arg)char *name;int arg;{    errno = 0;    switch (*name) {    }    errno = EINVAL;    return 0;not_there:    errno = ENOENT;    return 0;}double				maxLinkage;				// Maximum distance that markers can be considered linkedint					tossExtreme;			// Boolean indicating that the maximum distance should be discardeddouble				lodCutoff;				// The lod value representing allowed hitsint					maxAmbig;				// Maximum number of ambiguities allowed for a marker pairint					keepNextBest;			// How many next-best hits to keepint					numHybrids;				// Number of hybrids in the panel - needed for calculating n choose kint					debugOn;				// Boolean that allows text dump of structuresint					findLinkage;			// Boolean specifying a simpler output that measures probability dif between linked and unlinked modelsint					maxNameLength;			// Maximum length of model namesint					totLength = 0;			// totalLength of the names in theStatisticsint					maxVars;				// maximum number of variants, will be calculated laterambigClass**		allVars;				// Stores the ambiguity classesint					allCount = -1;			// index counter for number of ambiguity classesmodScore**			allHits;				// Stores the best hits for each modelstatic statistic*	theStatistics[100];		// Pointers to the statistics structuresint 				statCount = -1;			// index counter for theStatisticschar*				types[4] = {"AB","A0","B0","00"};ambigClass*			theVars;double				bestHit;				// Best lod (probability, actually) hitint					bestLink;				// The linkage state (0=linked, 1=unlinked) of the best hit modeldouble				linkLOD;				// The difference between the best hit and the best hit of different linkage statusdouble				sdLink;					// Related to linkLOD, but reflects the standard deviation of the models in question.int					extraHits;				// Tracks the number of over-LOD hitsint					totalStatModel=0;		// The total number of models, including oposite orientations/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */void showVars (void) {	int			i, h;	printf("<FONT COLOR=blue SIZE=+2><B>Output of all identified ambiguity variats</B></FONT><PRE>");	printf("%12.12s: ", "Instances");	for (i=0; i<=allCount; i++) {		printf("%3.0d ",allVars[i]->members);	}	printf ("\n");	for (h=0; h< 4; h++) {		printf("<FONT COLOR=blue>%12.12s</FONT>: ", types[h]);		for (i=0; i<=allCount; i++) {			printf("%3.0d ",allVars[i]->hybrids[h]);		}		printf ("\n");	}//	printf("%12.12s: ", "n Choose k");//	for (i=0; i<=allCount; i++) {//		printf("%.0f ",allVars[i]->choices);//	}//	printf ("\n");	printf ("</PRE>");}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */void killHit (modScore* hit) {					// Recursively travel down the tree and free up all the memory	if (hit->low != NULL) killHit(hit->low);	// Follow the low hit branch down	if (hit->high != NULL) killHit(hit->high);	// then follow the high branch down	free(hit);									// All branches should be trimmed, now kill this (sub) root}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */modScore* newHit (void) {			// Initialize a new model hit and set the pointers to null	int			i;	modScore*	hit;	hit = (modScore*) malloc (sizeof (modScore));	hit->low		= 0;	hit->high		= 0;	hit->root		= 0;	hit->isUnlinked	= -1;	return hit;}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */void showAllHits (modScore* hitPoint) {	if (hitPoint->low != NULL) showAllHits(hitPoint->low);		printf ("%30.30s : %8.3f ± %6.3f at %4.0f ± %6.2f\n", hitPoint->model, hitPoint->lod, hitPoint->lodDev, hitPoint->dist, hitPoint->distDev);		if (hitPoint->high != NULL) showAllHits(hitPoint->high);}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */void sortHit (modScore* hitPoint, char* out) {	char	thisResult[255];	if (hitPoint->low != NULL) sortHit(hitPoint->low, out);		// Climb down the low tree		if (bestHit == -1) bestHit = hitPoint->lod;					// This will be true when the base of the tree is reached. Set the bestHit to the lowest member of the tree	if (hitPoint->lod <= bestHit + lodCutoff) {					// Model is within the lod range specified, put it into output		sprintf(thisResult, "%.3f!!%.3f!!%.0f!!%.3f!!%s\t", hitPoint->lod, hitPoint->lodDev, hitPoint->dist, hitPoint->distDev, hitPoint->model);//		printf("<FONT COLOR=green>%s</FONT>\n", thisResult);		strcat(out, thisResult);	} else if (extraHits < keepNextBest) {						// Model was outside the LOD range, but user wants a few more "poor" models shown as well		sprintf(thisResult, "%.3f!!%.3f!!%.0f!!%.3f!!%s\t", hitPoint->lod, hitPoint->lodDev, hitPoint->dist, hitPoint->distDev, hitPoint->model);//		printf("<FONT COLOR=red>%s</FONT>\n", thisResult);		strcat(out, thisResult);		extraHits++;											// This counts towards the number of poor models displayed	}		if (hitPoint->high != NULL) sortHit(hitPoint->high, out);	// Climb up the high tree}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */// Finds the best model, then finds the next model with a different linkage statusvoid sortLink (modScore* hitPoint) {	if (hitPoint->low != NULL) sortLink(hitPoint->low);		// Climb down the low tree	if (bestHit == -1) {									// This will be true when the base of the tree is reached. Set the bestHit to the lowest member of the tree		bestHit 	= hitPoint->lod;		bestLink	= hitPoint->isUnlinked;		sdLink 		= hitPoint->lodDev;		linkLOD		= -999;	}	if (hitPoint->isUnlinked != bestLink) {					// Model does not have the same linkage status as the best model		if (linkLOD == -999) {								// This is the first model to meet the criteria: it is the best model of alternate linkage status			linkLOD = hitPoint->lod - bestHit;				// This is the LOD between the best model and the best one of the alternate linkage status			sdLink += hitPoint->lodDev;						// The sum of the standard deviations between the two models			if (bestLink == 1) {				linkLOD = -linkLOD;							// Negative values indicate more probable that markers are unlinked				sdLink = - sdLink;			}			sdLink = linkLOD - sdLink;						// This now represents the "worst possible case" LOD value between the two models		}		return;												// Don't bother climbing the tree any further	}		if (hitPoint->high != NULL) sortLink(hitPoint->high);	// Climb up the high tree}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */void setHit (modScore* self, modScore* theRoot, char* name, double la, double lsd, double da, double dsd, int unlinked) {	self->model			= name;	self->root			= theRoot;	self->lod			= la;	self->lodDev		= lsd;	self->dist			= da;	self->distDev		= dsd;	self->isUnlinked	= unlinked;}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */void addHit (modScore* theRoot, char* name, double la, double lsd, double da, double dsd, int unlinked) {	int			i;	modScore*	aHit;	if (theRoot->root == NULL) {				// New structure		setHit (theRoot, theRoot, name, la, lsd, da, dsd, unlinked);	 // Just initialize the variables in the first element	} else if (la < theRoot->lod) {				// Lower score than this struct		if (theRoot->low == NULL) {				// Nothing is lower, pop a new struct in that position			aHit			= newHit();			// Create a new struct			theRoot->low	= aHit;				// Set the flag of the current struct to point to it			setHit (aHit, theRoot, name, la, lsd, da, dsd, unlinked);	// Set the values for the new structure		} else {			addHit(theRoot->low, name, la, lsd, da, dsd, unlinked);	// Bump the results down to the next structure		}	} else if (la >= theRoot->lod) {			// Higher score than this struct		if (theRoot->high == NULL) {			// Nothing is high, pop a new struct in that position			aHit		= newHit();				// Create a new struct			theRoot->high	= aHit;				// Set the flag of the current struct to point to it			setHit (aHit, theRoot, name, la, lsd, da, dsd, unlinked);	// Set the values for the new structure		} else {			addHit(theRoot->high, name, la, lsd, da, dsd, unlinked);	// Bump the results down to the next structure		}	}}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */void killAC (ambigClass* ac) {					// Recursively travel down the tree and free up all the memory	if (ac->low != NULL) killAC(ac->low);		// Follow the low class branch down	if (ac->high != NULL) killAC(ac->high);		// then follow the high branch down	free(ac);									// All branches should be trimmed, now kill this (sub) root}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */ambigClass* newAC (void) {			// Initialize a new ambiguity class and set the pointers to null	ambigClass*	ac;	ac = (ambigClass*) malloc (sizeof (ambigClass));	ac->low		= 0;	ac->high	= 0;	ac->members = 0;	return ac;}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */// This has been verified as functioning properlydouble nChooseK (int n, int k) {	int		i;	double	r = 1;	for (i=1; i <= n; i++)		r *= i;	for (i=1; i <= k; i++)		r /= i;	for (i=1; i <= (n-k); i++)	r /= i;	return r;}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */void setAC (ambigClass* ac, int* hy, double sc) {	int		i;	int		remain = numHybrids;	ac->choices = 1;	for (i = 0; i< 4; i++) {		ac->hybrids[i] = hy[i];		ac->choices *= nChooseK (remain, hy[i]);		remain -= hy[i];	}	if (remain != 0 ) printf("<FONT COLOR=red>Major error! Choice determination while calculating probabilites results in remainder of %d (should be zero).</FONT><BR>\n", remain);	ac->score	= sc;	ac->members	= 1;	allCount++;	allVars[allCount] = ac;}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */void addAC (ambigClass* ac, int* hy, double sc) {	int			i;	ambigClass*	anAC;	if (ac->members == 0) {						// New structure		setAC (ac, hy, sc);						// Just initialize the variables in the first element	} else if (sc < ac->score) {				// Lower score than this struct		if (ac->low == NULL) {					// Nothing is lower, pop a new struct in that position			anAC	= newAC();					// Create a new struct			ac->low	= anAC;						// Set the flag of the current struct to point to it			setAC (anAC, hy, sc);				// Set the values for the new structure		} else {			addAC (ac->low, hy, sc);			// Bump the results down to the next structure		}	} else if (sc > ac->score) {				// Higher score than this struct		if (ac->high == NULL) {					// Nothing is high, pop a new struct in that position			anAC		= newAC();				// Create a new struct			ac->high	= anAC;					// Set the flag of the current struct to point to it			setAC (anAC, hy, sc);				// Set the values for the new structure		} else {			addAC (ac->high, hy, sc);			// Bump the results up to the next structure		}	} else {									// Same score as this struct		ac->members++;							// Simply increment the counter for that struct	}}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */double findScore (int* ambs) {	int		i;	double	s = 0;	for (i=0; i < 4; i++) {		s += ambs[i] * pow(1000, 3-i);	}	return s;}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */statistic* makestat (char* n, int el, char* d, char* AB, char* An, char* Bn, char* nn) {	statistic*	new;	int			i;	double* dPtr	= (double*)d;	double* abPtr	= (double*)AB;	double* anPtr	= (double*)An;	double* bnPtr	= (double*)Bn;	double* nnPtr	= (double*)nn;	new				= (statistic*) malloc (sizeof (statistic));	new->model[0]	= (char*) malloc (strlen(n)*sizeof(char));	totalStatModel++;	new->numDist	= el;	new->orient		= 0;	new->isUnlinked	= 0;	new->maxDist	= el;//	printf("Got %s",n);	strcpy(new->model[0], n);	if (strlen(n) > maxNameLength) maxNameLength = strlen(n);	totLength += strlen(n) + 1;	for (i=0; i <= el; i++) {			// Load the values from the packed arrays into the structure		new->dist[i]	= dPtr[i];		new->prob[0][0][i] = abPtr[i];		new->prob[0][1][i] = anPtr[i];		new->prob[0][2][i] = bnPtr[i];		new->prob[0][3][i] = nnPtr[i];		if (new->prob[0][1][i] != new->prob[0][2][i]) new->orient = 1;		if ((new->dist[i] > maxLinkage) && (new->maxDist == el)) {			new->maxDist	= i;			new->keepDist	= i;			if (tossExtreme == 1) new->keepDist	= i-1;//			printf("%30.30s: %f exceeds %f, set to %d<BR>\n", new->model[0], new->dist[i], maxLinkage,new->maxDist);		}	}	if (new->orient == 1) {				// There are two marker orientations, we need to make allowances for this		new->model[1]	= (char*) malloc (strlen(n)*sizeof(char));		totalStatModel++;		strcpy(new->model[1], new->model[0]);			// Start by making the second model name the same as the first		for (i=0; i < strlen(n); i++) {			if (n[i] == 'A') new->model[1][i] = 'B';	// Replace all instances of A with B			if (n[i] == 'B') new->model[1][i] = 'A';		}		for (i=0; i <= el; i++) {			// Now set the second probability set			new->prob[1][0][i] = new->prob[0][0][i];	// AB - same as the original orientation			new->prob[1][3][i] = new->prob[0][3][i];	// 00 - same as the original orientation			new->prob[1][1][i] = new->prob[0][2][i];	// A0 should be set to B0			new->prob[1][2][i] = new->prob[0][1][i];	// B0 should be set to A0		}	}	if (el == 0) {						// Invariant Model			new->maxDist	= 0;			new->keepDist	= 0;			new->isUnlinked	= 1;	}	return (new);}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */void showStats (void) {		int 		i, j, k;	statistic*	sc;		printf("<FONT COLOR=blue SIZE=+2><B>Statistical model summary</B></FONT><BR><PRE>");	for (i=0; i<= statCount; i++) {		sc = theStatistics[i];		printf("<FONT COLOR=green><B>%s</B></FONT> ", sc->model[0]);		if (sc->isUnlinked) printf("<i>Invariant Model</i>");		printf("\n    <U>");		for (j=0; j<= sc->numDist; j++) {			printf("%6.0f ", sc->dist[j]);			if (j == sc->maxDist) printf ("<FONT COLOR=brown>");		}		printf ("</U></FONT>\n");		for (k=0; k<4; k++) {			printf(" <FONT COLOR=blue>%2.2s</FONT> ", types[k]);			for (j=0; j<= sc->numDist; j++) {				printf("%6.4f ", sc->prob[0][k][j]);				if (j == sc->maxDist) printf ("<FONT COLOR=brown>");			}			printf("</FONT>\n");		}	}	}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */void calcStats (modScore* theRoot) {	int		i, or, n, d, j, size;	size = allCount + 1;	for (i=0; i <= statCount; i++) {				// Loop through all the statistical models		statistic*	s = theStatistics[i];		for (or=0; or <= s->orient; or++) {			// Loop through the orientations (0 or 1)			double		logs[size];					// Array to hold best -log probabilities			double		dist[size];					// Array to hold best distances			double		tt = 0;						// Total number of variants			double		da = 0;						// Average distance			double		la = 0;						// Average LOD score			double		dsd = 0;					// Standard deviation for distance			double		lsd = 0;					// Standard deviation for LOD score			double		debug;			for (n=0; n <= allCount; n++) {			// Loop through the ambiguity variants				ambigClass*	ac = allVars[n];		// The current ambiguity variant				double		max = 0;				double		dumb1, dumb2;				int			maxD = 0;				for (d=0; d <= s->maxDist; d++) {	// Loop through the distances					double prob = ac->choices;		// The probability is initialized to nChooseK choices					for (j=0;j<4;j++) {				// Loop through the four hybrid classes						prob *= pow(s->prob[or][j][d],ac->hybrids[j]);						// NEED TO ADJUST PROBABILITIES FOR ORIENTATION!						// I don't know why I have put this note in here...					}					if (prob > max) {						max		= prob;						maxD	= d;					}				}				if (max == 0) {					printf ("<FONT COLOR=red>ALERT: Maximum probability of zero found for %s. This is very unlikely!! The model is being skipped...</FONT>\n", s->model[or]);				}				logs[n]	= -log10(max);				dist[n]	= s->dist[maxD];				tt		+= (double)ac->members;		// The number of possible ambiguities that are represented by this class				da		+= ac->members * dist[n];	// The distance contribution is then the product of the number of members by the best distance				la		+= ac->members * logs[n];	// Likewise for lod scores			}			da /= tt;								// The average distance is the sum divided by the total number of ambiguities			la /= tt;								// Same for lods			for (n = 0; n <= allCount; n++) {		// Calculate the standard deviation for both distance and lod scores				dsd		+= (dist[n] - da) * (dist[n] - da) * (allVars[n]->members);				lsd		+= (logs[n] - la) * (logs[n] - la) * (allVars[n]->members);			}			lsd = sqrt (lsd/tt);			dsd = sqrt (dsd/tt);			if (da <= s->dist[s->keepDist]) {		// The average distance is within the keeping range, let's add it to the output collection				addHit (theRoot, s->model[or], la, lsd, da, dsd, s->isUnlinked);				// NOTE: This will result in total rejection of some alternate models, generally when the favored model is unlinked.				// The reason for this is that at extreme distances linked models behave as unlinked, and will be spuriously reported				// as having a similar probability as the unlinked model.	//			printf ("%30.30s %8.3f ± %6.3f at %8.3f ± %6.3f\n", s->model[or], la, lsd, da, dsd);			}		}	}}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */void findVariants(char* markerA, char* markerB) {	int		i, a, b, c;	int		fixed[] = { 0, 0, 0, 0 };		// AB=0, A0=1, 0B=2, 00=3	int		var[4];							// Will hold the variable hybrid contents	int 	ambig[MAXHYB];					// Will hold indices pointing at variant	int		aCount[MAXHYB];					// Will cycle through the 	int		ambigCounter = -1;				// The (index) number of ambiguous positions	int		variant[5][5] =	{	{	2,	3,	-1,	-1,	-1},		// 02 = 0B , 00								{	0,	1,	-1,	-1,	-1},		// 12 = AB , A0								{	1,	3,	-1,	-1,	-1},		// 20 = A0 , 00								{	0,	2,	-1,	-1,	-1},		// 21 = AB , 0B								{	0,	1,	2,	3,	-1}		};	// 22 = AB , A0 , 0B , 00	int		num[]		= { 1, 1, 1, 1, 3 };					// The number of entries in each row of variant	int		numTwos[]	= { 1, 1, 1, 1, 2 };					// The number of twos that would be present at that position	int		totTwos		= 0;									// Tracking the total twos observed in a marker pair	int		combos[3][3];	double	sc;		combos[0][2]	= 0;	combos[1][2]	= 1;	combos[2][0]	= 2;	combos[2][1]	= 3;	combos[2][2]	= 4;		for (i=0; i < MAXHYB; i++) {		aCount[i] = 0;	}	for (i=0; i < strlen(markerA); i++) {		a		= markerA[i] - 48;		b		= markerB[i] - 48;		if ( (a != 2) && ( b != 2) ) {		// No ambiguous results, log it in fixed			c = 3 - a*2 - b;				// Calculates the proper bin to put the result in			fixed[c]++;		} else {							// The hybrid has at least one ambiguous result			ambigCounter++;			ambig[ ambigCounter ] = combos[a][b];			totTwos += numTwos[ combos[a][b] ];		}	}		if (debugOn) {		printf ("<PRE>Marker A=%s\n", markerA);		printf ("Marker B=%s\n", markerB);		printf ("A total of %d twos found.<BR>\n<PRE>", totTwos);	}		if (ambigCounter > -1 ) {				// Ambiguous assays found		while ( aCount[ ambigCounter+1 ] == 0 ) {			for (i=0; i <= 3; i++) {		// Set the variable hybrid contents to that of the "fixed" ones at the start				var[i] = fixed[i];			}			for (i=0; i <= ambigCounter; i++) {				 int p = ambig[ i ];		// The index for this ambiguous locus (0-4)				 if (aCount[i] > num[p]) {	// The counter for the locus exceeds the maximum number of entries				 	aCount[i] = 0;			// Reset the counter				 	aCount[i+1]++;			// And increment the next one				 }				 var[ variant[p][aCount[i]] ]++;			}			aCount[0]++;					// Increment the "lowest" counter			sc = findScore (var);			if ( aCount[ ambigCounter+1 ] == 0 ) addAC (theVars, var, sc);		// Because counter checking will occur in the *next* loop, one extra  variant will be added		}	} else {		addAC (theVars, fixed, 0);	}}/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */#line 548 "Probability.c"XS(XS_Probability_constant){    dXSARGS;    if (items != 2)	croak("Usage: Probability::constant(name,arg)");    {	char *	name = (char *)SvPV(ST(0),PL_na);	int	arg = (int)SvIV(ST(1));	double	RETVAL;	RETVAL = constant(name, arg);	ST(0) = sv_newmortal();	sv_setnv(ST(0), (double)RETVAL);    }    XSRETURN(1);}XS(XS_Probability_setValues){    dXSARGS;    if (items != 1)	croak("Usage: Probability::setValues(stuff)");    {	char*	stuff = (char *)SvPV(ST(0),PL_na);#line 552 "Probability.xs"		double* ptr		= (double*)stuff;		int				i;//		for (i=0; i <= 4; i++) {//			printf("Import Value %d = %f<BR>\n",i,ptr[i]);//		}		maxLinkage		= ptr[0];		tossExtreme		= (int)ptr[1];		lodCutoff		= ptr[2];		maxAmbig		= (int)ptr[3];		keepNextBest	= (int)ptr[4];				numHybrids		= (int)ptr[5];				debugOn			= (int)ptr[6];		findLinkage		= (int)ptr[7];		if (maxAmbig > MAXAMB) {			printf("<FONT COLOR=red>OVER-RULED: The program has limited you to %d ambiguities for processor conservation!</FONT><BR>\n",MAXAMB);			maxAmbig = MAXAMB;		}		maxVars = pow(2,maxAmbig);		if (debugOn != 0) {			printf("<FONT COLOR=blue SIZE=+1><B>General Values Passed on by Perl</FONT></B>:<PRE>");			printf("maxLinkage   = %.0f\n", maxLinkage);			printf("lodCutoff    = %.2f\n", lodCutoff);			printf("tossExtreme  = %d\n", tossExtreme);			printf("maxAmbig     = %d\n", maxAmbig);			printf("keepNextBest = %d\n", keepNextBest);			printf("numHybrids   = %d\n", numHybrids);			printf("debugOn      = %d\n", debugOn);			printf("</PRE>");		}#line 605 "Probability.c"    }    XSRETURN_EMPTY;}XS(XS_Probability_simplePower){    dXSARGS;    if (items != 2)	croak("Usage: Probability::simplePower(prob, power)");    {	double	prob = (double)SvNV(ST(0));	double	power = (double)SvNV(ST(1));	double	RETVAL;#line 590 "Probability.xs"	double	d;	extern	double pow(double x, double y);	d = pow(prob, power);	RETVAL = d;#line 626 "Probability.c"	ST(0) = sv_newmortal();	sv_setnv(ST(0), (double)RETVAL);    }    XSRETURN(1);}XS(XS_Probability_addStatistic){    dXSARGS;    if (items != 7)	croak("Usage: Probability::addStatistic(n, el, d, AB, An, Bn, nn)");    {	char*	n = (char *)SvPV(ST(0),PL_na);	int	el = (int)SvIV(ST(1));	char*	d = (char *)SvPV(ST(2),PL_na);	char*	AB = (char *)SvPV(ST(3),PL_na);	char*	An = (char *)SvPV(ST(4),PL_na);	char*	Bn = (char *)SvPV(ST(5),PL_na);	char*	nn = (char *)SvPV(ST(6),PL_na);#line 610 "Probability.xs"	statistic* stat;#line 649 "Probability.c"	int	RETVAL;#line 613 "Probability.xs"	stat = makestat(n, el, d, AB, An, Bn, nn);	statCount++;	theStatistics[statCount] = stat;	RETVAL = statCount;#line 657 "Probability.c"	ST(0) = sv_newmortal();	sv_setiv(ST(0), (IV)RETVAL);    }    XSRETURN(1);}XS(XS_Probability_modelOrder){    dXSARGS;    if (items != 1)	croak("Usage: Probability::modelOrder(void)");    {#line 625 "Probability.xs"	char	out[totLength];						// totLength tracks the total number of space needed to construct this string	int		i;#line 674 "Probability.c"	char *	RETVAL;#line 629 "Probability.xs"	for (i=0; i < statCount; i++) {				// Build string containing model names in order		strcat(out, theStatistics[i]->model[0]);		strcat(out, "\t");						// Separate entries with tabs	}	RETVAL = out;#line 683 "Probability.c"	ST(0) = sv_newmortal();	sv_setpv((SV*)ST(0), RETVAL);    }    XSRETURN(1);}XS(XS_Probability_twoVector){    dXSARGS;    if (items != 2)	croak("Usage: Probability::twoVector(markerA, markerB)");    {	char*	markerA = (char *)SvPV(ST(0),PL_na);	char*	markerB = (char *)SvPV(ST(1),PL_na);#line 644 "Probability.xs"	modScore*	modHits[statCount];	modScore*	theHits;	int			totalSize = totalStatModel * (30 + maxNameLength);	char		output[totalSize];#line 704 "Probability.c"	char *	RETVAL;#line 651 "Probability.xs"	if ((strlen(markerA) != numHybrids) || (strlen(markerB) != numHybrids)) {		printf("<FONT COLOR=red>Vector error! At least one of the following vectors does not have exactly %d hybrids:<BR>", numHybrids);		printf ("<PRE>Marker A=%s\n", markerA);		printf ("Marker B=%s\n</FONT></PRE>", markerB);		return;	}	allCount	= -1;	bestHit		= -1;					// The probability of the best model (set to a bogus value here)	bestLink	= -1;					// The linkage state of the best model (set to a bogus value here)	output[0]	= '\0';	extraHits	= 0;	theVars		= newAC ();				// Will be root of the ambiguity classes	allVars		= (ambigClass**) malloc (maxVars * sizeof (ambigClass*));	theHits		= newHit();				// Will be root of hit tree	allHits		= (modScore**) malloc ((statCount+1) * sizeof (modScore*));	findVariants(markerA, markerB);	calcStats(theHits);	if (findLinkage) {									// Request to just calculate the LOD value to the best model of alternate linkage class		sortLink(theHits);		if (linkLOD == -999) {							// No model of opposite linkage found 			linkLOD = sdLink = 50;						// Set to arbitary large value			if (bestLink == 1) {				linkLOD = -linkLOD;						// Negative values indicate more probable that markers are unlinked				sdLink = - sdLink;			}		}		sprintf(output, "%.3f\t%.3f", linkLOD, sdLink);	// The output will just be the LOD score and standard dev LOD.	} else {		sortHit(theHits, output);	}	if (debugOn) {		showVars();		printf("<FONT COLOR=blue SIZE=+2><B>Statistics for all models tested on marker pair:</B></FONT><PRE>");		showAllHits(theHits);	}	/* Tidy up the memory */	killAC(theVars);	free(allVars);	killHit(theHits);	free(allHits);	RETVAL = output;#line 753 "Probability.c"	ST(0) = sv_newmortal();	sv_setpv((SV*)ST(0), RETVAL);    }    XSRETURN(1);}XS(XS_Probability_showStatistics){    dXSARGS;    if (items != 1)	croak("Usage: Probability::showStatistics(void)");    {#line 705 "Probability.xs"	showStats();#line 768 "Probability.c"    }    XSRETURN_EMPTY;}#ifdef __cplusplusextern "C"#endifXS(boot_Probability){    dXSARGS;    char* file = __FILE__;    XS_VERSION_BOOTCHECK ;        newXS("Probability::constant", XS_Probability_constant, file);        newXS("Probability::setValues", XS_Probability_setValues, file);        newXS("Probability::simplePower", XS_Probability_simplePower, file);        newXS("Probability::addStatistic", XS_Probability_addStatistic, file);        newXS("Probability::modelOrder", XS_Probability_modelOrder, file);        newXS("Probability::twoVector", XS_Probability_twoVector, file);        newXS("Probability::showStatistics", XS_Probability_showStatistics, file);    XSRETURN_YES;}
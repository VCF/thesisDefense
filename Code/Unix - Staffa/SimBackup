#!/usr/local/bin/perlBEGIN {    print "Content-type: text/html\n\n";    # Ensure that errors go to the web browser. From Steve's Primer3 program    open(STDERR, ">&STDOUT");    $| = 1;    print '';    push @INC, "/usr/local/etc/httpd/cgi-bin/pagelab/charles/Probability";    push @INC, "/usr/local/etc/httpd/cgi-bin/pagelab/charles/CalcTheta";}# Staffa path for this file is:# /usr/local/etc/httpd/cgi-bin/pagelab/charles/# SimulateRH.cgi# A Radiation Hybrid simulator with predictive capacity# Charles Tilford, 2000# Whitehead Institute / Massachusetts Institute of Technology# My stupid reminders on how to use XS:# Move to directory with .xs file and execute	: perl Makefile.PL# Then execute									: make# Find the #!@%@ .so file. It was burried in	: blib/arch/auto/Probability# Move a copy to the Probability level, or put the above in @INC. That's it! strict;use CGI;use GD;use Probability;use CalcTheta;require "ParseQuery.pl";# $cDebugger = 1;&DEFINECONSTANTS;&PARSE;&FILEDUMP($Dump) if ($Dump);if ($filename) {	if ($noStore) {		&LOADDATA;		&DYNAMICLOAD;	} else {		&EXTERNALLOAD;	}}&HELPME			if ($helpMe);&STARTHTML;&LOADDATA;&SHOWSTATS		if ($ShowStats);&SHOWVECTORS	if ($ShowVectors);&PRINTOPTIONS;&SEQCOMPARE		if ($seqCompare);# $a = Probability::twoVector($myVectors{"sY1"}, $myVectors{"sY2"}); @t = split "\t", $a; foreach $i (@t) { print "$i<BR>\n"; }if ($filename ne "") {	print "<FONT COLOR=green>Your file was loaded. You may now use the options above to analyze it.</FONT><BR>\n";	exit;}unless ($doPredict eq "" || $doPredict eq "No Prediction") {	my $targ = \@vecOrder;	@tempOrder = ();	if ($myMarkers) {		@tempOrder = split /[\r\n]/, $myMarkers;		$targ = \@tempOrder;	}	@holding = (); my @unfound = ();	for my $i (0..$#{$targ}) {		next if (${$targ}[$i] eq "");		if (exists $myVectors{ ${$targ}[$i] }) {			push @holding, ${$targ}[$i];		} else {			push @unfound, ${$targ}[$i];		}	}	if ($#unfound > -1) {		my $tot = $#holding +1; my $unf = $#unfound + 1;		print qq(<FONT COLOR=red><B>Could not find the following $unf markers ($tot were found) in the local vector file:</B>\n);		print "<PRE>";		for my $i (0..$#unfound) {			print "\n" unless ($i % 6);			printf ("%15.15s ", $unfound[$i]);		}		print "</FONT></PRE>";	}	$targ = \@holding;	if ($doPredict =~ /all/i) {							# Do a full grid analysis		if ($gridOrder =~ /alph/i) {					# Arrange markers alphabetically			@tempOrder = sort {$a cmp $b} @{$targ};			$targ = \@tempOrder;		}		if ($findLinkage) {			LINKAGETEST($targ, "PredictionOutput");		} else {			&GRIDPREDICT($targ, "PredictionOutput");		}	} elsif ($doPredict eq "Neighbors") {		&NEIGHBORPREDICT($targ, "PredictionOutput");	}	exit;}if ($thePanel) {	if ($scanStep > 0) {		&STEPRUN($thePanel, "A","B");	}}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub SEQCOMPARE {	print "<CENTER><TABLE><TR><TD BGCOLOR=yellow WIDTH=300><CENTER>";	print "<FONT COLOR=brick SIZE=+4><B>Please do not disturb</B></FONT></TABLE></CENTER><BR>\n";	my $dir = "$HOME/Data/ChrYMarkers";		# The directory where the clones lurk	my @fileList = split "\n", `ls $dir`;	open (FILE, ">$HOME/Data/PlotData") or die "SEQCOMPARE: Can't write PlotData: $!\n";	print FILE "LOD\tDistance (kb)\tMarker A Sites\tMarker B Sites\tTheta\n";	close FILE;		undef(%primerSites); undef(%fullSites); 	foreach $f (@fileList) {		open (FILE, "$dir/$f") or die "SEQCOMPARE: Can't read $dir/$f: $!\n";		my ($chunkName, $chunkSize) = split "\t", <FILE>;		while (<FILE>) {			chomp;			my @temp = split "\t", $_;			my $sts = shift @temp;			$primerSites{$sts}	+= 	shift @temp;			$fullSites{$sts}	+= $#temp + 1;		}		close FILE;	}		foreach $f (@fileList) {		print "<FONT COLOR=green SIZE=+2><B>$f</B></FONT><BR>\n";		my %positions = (); my @group = (); my %primerSites = ();		open (FILE, "$dir/$f") or die "SEQCOMPARE: Can't read $dir/$f: $!\n";		($chunkName, $chunkSize) = split "\t", <FILE>;		while (<FILE>) {			chomp;			my @temp = split "\t", $_;			my $sts = shift @temp;			$primerSites{$sts} =	shift @temp;			@{$positions{$sts}} = @temp;		}		close FILE;		&PLOTSTS(\%positions, $chunkSize);				foreach $sts (keys %positions) {			push @group, $sts if (exists $myVectors{ $sts });		}		@group = sort {$a cmp $b} @group;		open (FILE, ">>$HOME/Data/PlotData") or die "SEQCOMPARE: Can't append to PlotData: $!\n";		print "<PRE><i><FONT COLOR=brown>Now checking: </FONT></i>";		for $col (0..($#group - 1)) {			print "\n" unless ($col % 8);			$aMarker = $group[$col];			printf ("%12s ", $aMarker);			for $row (($col+1)..$#group) {				$bMarker = $group[$row];				foreach $a (@{$positions{$aMarker}}) {					foreach $b (@{$positions{$bMarker}}) {						my $theDist = abs($a - $b);						$dist = $theDist if ($theDist < $dist);		# Find the closest pair of markers					}				}				next if ($dist == 0);								# Zero distance markers are a pain to deal with when plotting on log axes				my @Output = ();				my $totTwo = $myVectors{$aMarker} . $myVectors{$bMarker};				my @tmpA = ($totTwo =~ /(2)/g);						# Count the combined number of twos				$totTwo = $#tmpA + 1;				next if ($totTwo > $maxAmbig);							# Too many Ambiguous				my ($theLOD, $devLOD) = split "\t", Probability::twoVector($myVectors{$aMarker}, $myVectors{$bMarker});				my $dist = 999999999999;				printf FILE ("%.3f\t%.3f\t%s\t%s\t%.3f\n", $theLOD, $dist/1000, $fullSites{$aMarker}, $fullSites{$bMarker}, 						CalcTheta::findTheta($myVectors{$aMarker}, $myVectors{$bMarker}));			}		}		close FILE;		print "</PRE>";	}}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub PLOTSTS {	my $posRef		= shift;	# [0] reference to hash containing base pair position location for each marker	my $totalSize	= shift;	# [1] total size of genomic sequence, bp		my $bar			= 4;	# height of rectangle representing DNA	my $tick		= 6;	# height of ticks connecting markers to DNA bar	my $tickgap		= 2;	# space between tick and marker name	my $maxChars	= 8;	# Maximum number of characters to print in a name	my $Border		= 20;	# empty space on edges of DNA	my $kbPerPix	= 3;	# Number of kilobases represented by one pixel	my $bpPerPix	= $kbPerPix * 1000;	$height			= $bar + $tick + $tickgap + $wT * $maxChars;	$width			= $Border*2 + $totalSize/$bpPerPix;	$gph			= new GD::Image($width,$height);	$white			= $gph->colorAllocate(255,255,255);	$almostWhite	= $gph->colorAllocate(255,255,254);	$black			= $gph->colorAllocate(0,0,0);	$blue			= $gph->colorAllocate(0,0,255);	$orange			= $gph->colorAllocate(255,128,0);	$red			= $gph->colorAllocate(255,0,0);	$yellow			= $gph->colorAllocate(255,255,0);	$green			= $gph->colorAllocate(0,128,0);	$purple			= $gph->colorAllocate(255,0,128);	$ltblue			= $gph->colorAllocate(128,128,255);	$gray			= $gph->colorAllocate(150,150,150);		my $halfHeight	= int ($hT/2);	my $tickY2		= $height - $bar - 1;	my $tickY1		= $tickY2 - $tick;	my $textY		= $tickY1 - $tickgap;	$gph->filledRectangle($Border,$height-$bar,$width-$Border,$height,$orange);		my @toSort = ();	my %markPos = %{$posRef};	my $skipped = my $notRH = 0;	foreach $sts (keys %markPos) {		unless (exists $myVectors{ $sts }) {			$skipped += $#{$markPos{$sts}} + 1; $notRH += $#{$markPos{$sts}} + 1;			next;		}		foreach $p (@{$markPos{$sts}}) {			push @toSort, sprintf("%12s\t%s", $p, $sts);		}		$col{$sts} = $#{$markPos{$sts}} > 0 ? $blue : $black;	}	@toSort = sort {$a cmp $b} @toSort;	push @toSort, "99999999999999\tDummy";	my $lastTex = 0;	my $minSpace = $hT + 1;	for $i (0..$#toSort) {		my ($pos, $sts) = split "\t", $toSort[$i];		my $pix = $Border + $pos / $bpPerPix;		my $tex = $pix - $halfHeight;		my $skew = 0;		my ($posNext, $d) = split "\t", $toSort[$i+1];		my $nextTex = $Border + ($posNext / $bpPerPix) - $halfHeight;		if ($lastTex + $minSpace > $tex) {		# Will the item conflict with the prevous marker?			if ($lastTex + $minSpace * 2 < $nextTex) {				$tex = $lastTex + $minSpace;	# We can squeeze the marker in between the flanking markers			} else {				$skipped++;				next;							# Can't fit it in, skip it			}		} elsif ($tex + $minSpace > $nextTex) {	# There *will be* a conflict with the next marker			if ($lastTex + $minSpace * 2 < $nextTex) {				$tex = $nextTex - $minSpace;	# We can squeeze the marker in between the flanking markers			}		}		$gph->line($tex+$halfHeight, $tickY1, $pix, $tickY2, $orange);		$gph->stringUp(gdTinyFont,$tex,$textY,$sts,$col{$sts});		$lastTex = $tex;	}		$plotCounter++;	my $fileName = "Sequence-$plotCounter-$$.gif";	open (FILE, ">$DataLoc/$fileName") or die "Failure to write to $fileName: $!\n";	print FILE $gph->gif;	close FILE;	print qq(<img src="$DataLoc/$fileName"><BR>);	print "<i>$skipped markers were skipped, $notRH because they have not been RH mapped.</i><BR>\n";}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub TESTC {	my $time1 = time;	$loops = 1000000;	for my $test (1..$loops) {		$x = Probability::simplePower(3,3);	}	$time1 = time - $time1;	my $time2 = time;	for my $test (1..$loops) {		$x = &PROBPOWER(3,3);	}	$time2 = time - $time2;	$rat = $time2 / $time1;	print "C-time $time1 / Perl-time $time2 = $rat<BR>\n";}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - # [0] - ref to the chromosome# [1] - name of "MarkerA"# [2] - name of "MarkerB"sub STEPRUN {	my $chromosome	= shift;	my $MarkerA		= shift;	my $MarkerB		= shift;	my $fileN		= "SimulationOutput";	if ($scanLow < 0 || $scanHigh < $scanLow or $scanStep <= 0) {		print "<FONT COLOR=red>Uh, you seem to have put in flaky values for the scan settings. Please re-enter such that:<BR>\n";		print "The low value is at least zero<BR>\n";		print "The high value is greater than the low one<BR>\n";		print "The step value is greater than zero.<BR></FONT>\n";		return;	}	my @Dist = (); my %Values = ();	print "<B>Distances being used:</B><BR>";	if ($logDist) {		my $minY = 1 - 1/exp($lambda * $scanLow);		my $maxY = 1 - 1/exp($lambda * $scanHigh);		my $scanSpace = ($maxY - $minY) / ($scanStep - 1);		my $x = 0;		for (my $y = $minY; $#Dist < $scanStep - 1; $y += $scanSpace) {		# Use $#Dist as primary counting mechanism			$x =  abs(int (0.5 -log(1 - $y) / $lambda));					# abs helps avoid negative zero			push @Dist, $x;			print "$x kb<BR>";		}	} else {		my $scanSpace = ($scanHigh - $scanLow) / ($scanStep - 1);		for (my $i = $scanLow; $i <= $scanHigh; $i += $scanSpace) {			push @Dist, $i;			print "$i kb<BR>";		}	}	my @checking = ();	my $plotWidth	= 250;	my $plotHeight	= 200;	if ($chromosome eq "All") {		foreach my $n (@theChr) {#			print "--> $n<BR>";			push @checking, $Chromosomes{$n};		}	} else {		@checking = ($Chromosomes{$chromosome});		$plotWidth	= 600;		$plotHeight	= 400;	}	&SAVEPREP($fileN);	$theTime = time;	print "<TABLE BORDER=1>";	$cols = 3;	for my $chr (0..$#checking) {		next unless (defined $chr);		print "<TR>" unless ($chr % $cols);		print "\n<TD>";		$checking[$chr]->calcProbs(\%GV, \@Dist, \%Values);		my $ABequal = 1;		foreach my $d (@Dist) {			if ($Values{"A$nullToken"}[$d] != $Values{"B$nullToken"}[$d]) {				$ABequal = 0;				last;			}		}		if ($ABequal) {			delete $Values{"B$nullToken"};			@{$Values{"A$nullToken & B$nullToken"}} = @{$Values{"A$nullToken"}};			delete $Values{"A$nullToken"};		}		&SAVEDATA(\%Values, \@Dist, $checking[$chr], $fileN);		my @plots = ( \%Values ); my @labels = ($checking[$chr]->{Name});		&XYPLOT(\@labels, \@plots, \@Dist, $plotWidth, $plotHeight, "$DataLoc/Plot$chr$$.gif");	}	print "</TABLE>\n";	$theTime = time - $theTime;	$theOperations = ($#checking + 1) * ($#Dist+1);	&SAVEEND($fileN);}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub SHOWSTATS {	print "<TABLE BORDER=1>";	my $cols = 4; my $count = 0; my %sameRF = ();	for my $sts (0..$#Statistics) {		print "<TR>" unless ($count % $cols);		print "\n<TD>";		my @plots = ( \%{$Statistics[$sts]->{Probability}} );		my $name = $Statistics[$sts]->{Model};		my @labels = ( $name ); my @content = ();		for (my $i = 0; $i <= length($name)-1; $i += 2) {	# Take every other character (should be marker name) and collect them			push @content, substr($name, $i,1);		}		@content = sort {$a cmp $b} @content;		$sig = join '', @content;#		print "$name->$sig.";		push @{$sameRF{$sig}}, $sts;		&XYPLOT(\@labels, \@plots, \@{$Statistics[$sts]->{Distance}}, 200, 150, "$DataLoc/Plot$sts$$.gif");		$count++;	}	foreach $sig (keys %sameRF) {		next if ($#{$sameRF{$sig}} < 1);		print "<TR>" unless ($count % $cols);		print "\n<TD>";		my @labels = ();		my @plots = ();		foreach $sts (@{$sameRF{$sig}}) {			push @plots,	\%{$Statistics[$sts]->{Probability}};			push @labels,	$Statistics[$sts]->{Model};#			print "$Statistics[$sts]->{Model}, ";		}		&XYPLOT(\@labels, \@plots, \@{$Statistics[$sts]->{Distance}}, 200, 150, "$DataLoc/MultiPlot$sts$$.gif");		$count++;	}	print "</TABLE>\n";	exit;}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub SHOWVECTORS {	my @vecKeys = @vecOrder;	@vecKeys = @vecAlpha if ($AlphaSort);	print "<H2><CENTER>Vectors stored locally:</CENTER></H2><PRE>";	foreach $n (@vecKeys) {		printf ("%15.15s ",$n);		$_ = $myVectors{$n};		my $swapOut = "<FONT COLOR=yellow>0</FONT>";		s/0/$swapOut/g;		my $swapOut = "<FONT COLOR=red>2</FONT>";		s/2/$swapOut/g;		print "$_\n";	}	print "</PRE>\n";	if ($AlphaSort) {		print qq(<FONT COLOR=orange><CENTER>View the list in the <A HREF="SimulateRH.cgi?ShowVectors=Y&dum=$$">original order</A> as found in file.</CENTER></FONT>\n);	} else {		print qq(<FONT COLOR=orange><CENTER>Sort the above list <A HREF="SimulateRH.cgi?ShowVectors=Y&AlphaSort=Y&dum=$$">alphabetically</A></CENTER></FONT>\n);	}	exit;}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - # [0] - filenamesub FILEDUMP {	print "<html><TITLE>Text Dump for file $_[0]</TITLE><BODY BGCOLOR=White>\n";	print "<PRE>";	open (FILE, "$DataLoc/$_[0]") or die "Failure to open $DataLoc/$_[0]: $!\n";	while (<FILE>) { print;}	print "</PRE>";	exit;}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub PROBPOWER {	my $p	= shift;		# [0] - p, the probability	my $n	= shift;		# [1] - n, the power to raise it to	my $r	= 1;	for my $i (1..$n) {		$r *= $p;	}	return $r;}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub NCHOOSEK {	my $n	= shift;		# [0] - n, the total number of possibilities	my $k	= shift;		# [1] - k, the number that you want to choose out of n	my $res = 1;	for my $i (1..$n) {		$res *= $i;	}	for my $i (1..$k) {		$res /= $i;	}	for my $i (1..($n-$k)) {		$res /= $i;	}	return $res;}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub FINDPROB {	my $dataRef		= shift;	# [0] - ref to hash containing the possible vector compositions	my $resultRef	= shift;	# [1] - ref to array for results	my %present		= ();	my @unique		= ();	my %count		= ();	my @options		= ("$nullToken$nullToken", "A$nullToken", "B$nullToken", "AB", "A$nullToken & B$nullToken");	my @ambKeys		= keys %{$dataRef};	my $tempTime;	foreach my $n (@ambKeys) {		my @sigParts = sort {$a cmp $b} keys %{${$dataRef}{$n}};		my $sig = "";		foreach my $sp (@sigParts) {		# Build a unique, but duplicatable, signature for each vector composition			$sig .= $sp . ${$dataRef}{$n}{$sp} . ",";		}		if ($present{$sig} eq "") {			push @unique, $n;				# The pattern has not been seen before			$count{$n}++;					# Establish a counter to track number of occurances of the pattern			$present{$sig} = $n;			# Tag this pattern as already being established		} else {			$count{ $present{$sig} }++;		# Increment the appropriate key of the existing pattern		}	}	@unique = sort {$a cmp $b} @unique;	my @nextBest	= my @consider	= ();	my %chooseMod	= my %thePoints	= ();	foreach my $n (@unique) {		$chooseMod{$n}			= 1;					# Will hold the number of n choose k possibilities for getting the pattern		my $remaining			= $numHybrids;			# Tracks number of unchoosen hybrids left		%{$thePoints{$n}[0]}	= %{${$dataRef}{$n}};	# The [0] set is first marker = A, second marker = B		foreach my $as (keys %{$thePoints{$n}[0]}) {	# Calculate n choose k possibilities for each event class			$chooseMod{$n} *= &NCHOOSEK($remaining, $thePoints{$n}[0]{$as});			$remaining -= $thePoints{$n}[0]{$as};		# Keep track of the number of hybrids not chosen yet		}		if ($remaining != 0) {			my $unch = "$remaining hybrids unchoosen";			$unch = "choosen " . abs($remaining) . " extra hybrids" if ($remaining < 0);			print "<FONT COLOR=red>WARNING: Variant $n has $unch. It should be zero!\n";			foreach my $as (keys %{$thePoints{$n}[0]}) {				print "   $as = $thePoints{$n}[0]{$as}\n";			}			print "</FONT>";		}		for my $os (0..1) {			$thePoints{$n}[$os]{"A$nullToken & B$nullToken"} = $thePoints{$n}[$os]{"A$nullToken"} + $thePoints{$n}[$os]{"B$nullToken"};		}		foreach my $as (@options) {			my $otherKey = $as;			$otherKey = "A$nullToken" if ($as eq "B$nullToken");			$otherKey = "B$nullToken" if ($as eq "A$nullToken");			$thePoints{$n}[1]{$otherKey} = $thePoints{$n}[0]{$as};		}#		print "<FONT COLOR=BLUE>Variant $n</FONT>\n";	}	## 	my @hits = ();	$tempTime = time;	################ MAIN LOOP FOR GENERATING PROBABILITIES ################	foreach my $stat (@Statistics) {		my $maxOrient	= 1;		# The number of orientations possible (1 if both A0 and B0 have unique probabilities, otherwise 0)		$maxOrient		= 0 if (exists $stat->{Probability}{"A$nullToken & B$nullToken"});		my @statKeys	= ();		my $maxDist		= $#{$stat->{Distance}};		for my $d (0..$#{$stat->{Distance}}) {			if (${$stat->{Distance}}[$d] > $maxLinkage) {				# Find the index of the distance that is just *greater* than the maximum allowed linkage distance				$maxDist = $d;											# 				last;			}		}				foreach my $k (keys %{$stat->{Probability}}) {			push @statKeys, $k if ($#{$stat->{Probability}{$k}} > -1);		}		for my $or (0..$maxOrient) {									# Orientation A/B Loop			my @logs = my @dist = my @numb = ();			foreach my $n (@unique) {									# Ambiguity Variants				my $max			= 0;									# The maximum probaility found				my $maxLoc		= -1;									# The distance index at which it was calculated				for my $d (0..$maxDist) {								# Distance Loop					my $prob = $chooseMod{$n};					foreach my $v (@statKeys) {						next if ($v eq "");						$prob *= Probability::simplePower($stat->{Probability}{$v}[$d], $thePoints{$n}[$or]{$v});					}					if ($max < $prob) {						$max	= $prob;						$maxLoc	= $d;					}				}				if ($max == 0) {					print "<FONT COLOR=red>ALERT: Maximum probability of zero found for $stat->{Model}. This is very unlikely!! The model is being skipped...</FONT>\n";					next;				}				push @logs, -log($max) / 2.303;				push @dist, ${$stat->{Distance}}[ $maxLoc ];				push @numb, $count{$n};			}						my $da = my $la = my $tt = 0;			next if ($#logs < 0);			for my $i (0..$#logs) {		# Tally up the total distances				$tt	+= $numb[$i];				$da	+= $dist[$i] * $numb[$i];				$la	+= $logs[$i] * $numb[$i];			}			$da /= $tt;									# The average distance			$la /= $tt;									# The average lod score			next if ($da >= $maxLinkage && $tossExtreme);		# If the best hit for the model is at the extreme allowed distance, assume that the markers are actually unlinked			my $dsd = my $lsd = 0;			for my $i (0..$#logs) {						# Calculate the standard deviation				$dsd	+= ($dist[$i]-$da) * ($dist[$i]-$da) * $numb[$i];				$lsd	+= ($logs[$i]-$la) * ($logs[$i]-$la) * $numb[$i];			}			if ($dist[0] =~ /inv/i) {	# Probabilities are invariant with distance				$da = "Unlinked";			} else {				$dsd	= int (0.5 + 1000 * sqrt ($dsd/$tt)) / 1000;				$da		= int (0.5 + 1000 * $da) / 1000;			}			$lsd = int (0.5 + 1000* sqrt ($lsd/$tt)) / 1000;			$_ = $stat->{Model};			if ($or == 1) {								# Best hit was found in alternative orientation, swap A and B tokens				s/A/X/g; s/B/A/g; s/X/B/g;			}			push @hits, sprintf("%7.3f!!%s!!%s!!%s!!%s", $la, $lsd, $da, $dsd, $_);		}	}		################ END MAIN LOOP FOR GENERATING PROBABILITIES ################	$fpMainLoopTime += time - $tempTime;		@hits = sort {$a cmp $b} @hits;	my @dum = split "\t", $hits[0];	my $nbCounter = 0;	for my $i (0..$#hits) {		my @mud = split "\t", $hits[$i];		$nbCounter++ if ($mud[0] - $dum[0] > $lodCutoff);		last if ($nbCounter > $keepNextBest);		push @{$resultRef}, $hits[$i];	}	my $uniqueVar = $#unique + 1;#	print "Total Prob Output:\n<PRE>"; for my $d (0..$#daDist) { print "\t$daDist[$d]";} print "\n";foreach my $k (keys %debug) { print "$k"; for my $v (0..$#{$debug{$k}}) { print "\t${$debug{$k}}[$v]"; } print "\n"; } print "<\PRE>";	return $uniqueVar;}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - # [0] - filename where data should be savedsub PREDICTPREP {	my $saveFile	= shift;	open (FILE, ">$DataLoc/$saveFile") or die "Failure to initialize $saveFile: $!\n";	print FILE "START\n\n";	print FILE "Value\tLOD Cutoff Limit\t$lodCutoff\n";	print FILE "Value\tMaximum Ambiguous Results\t$maxAmbig\n";	print FILE "Value\tMaximum Linkage Distance\t$maxLinkage\n";	print FILE "Value\tNumber Next-Best Matches\t$keepNextBest\n";	print FILE "\n";	close FILE;		undef (%HitCount);	undef (%lodSum1);	undef (%lodSum2);	undef (%distSum1);	undef (%distSum2);}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub PREDICTADD {	my $saveFile	= shift;	# [0] - filename where data should be saved	my $markerA		= shift;	# [1] - name of marker A 	my $markerB		= shift;	# [2] - name of marker B 	my $dataRef		= shift;	# [3] - ref to array holding data	open (FILE, ">>$DataLoc/$saveFile") or die "PREDICTADD: Failure to append to $saveFile: $!\n";	print FILE "$markerA\t$markerB";	foreach $n (@{$dataRef}) {		print FILE "\t$n";	}	print FILE "\n";	close FILE;	}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub PREPSTATVALS {}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - # This routine prepares the statistics for random cost ordering.# Because the matrix is non-symetrical, the average value ((X,Y) + (Y,X))/2 is taken for both X,Y and Y,X# Only points where both X and Y have data are used - the remainder are set to a large value ($bogusHit) to avoid their contribution to ordering# NEED TO MAKE FILES IN TMP FOLDERS, RATHER THAN IN MAIN ONEsub STATOUT {	my $saveFile	= shift;	# [0] - filename where data should be saved	my $theOrder = \@allModels;	my $statTime = time;	$bogusHit = 45;		# Calculate values for the purpose of random cost ordering	for $a (0..($#allModels-1)) {		my $topModel = $allModels[$a];		$val{$topModel}{$topModel} = 0;		for $b (($a+1)..$#allModels) {			my $secModel = $allModels[$b];			if (exists $HitCount{$topModel}{$secModel} && exists $HitCount{$secModel}{$topModel}) {				my $hits	= $HitCount{$topModel}{$secModel} + $HitCount{$secModel}{$topModel};				my $avgLod	= ($lodSum1{$topModel}{$secModel}  + $lodSum1{$secModel}{$topModel}) / $hits;				$val{$topModel}{$secModel} = $val{$secModel}{$topModel} = sprintf("%.2f", $avgLod);			} else {	# At least one of the models is screwy.				$val{$topModel}{$secModel} = $val{$secModel}{$topModel} = $bogusHit;			}		}	}	my @havesData = ();		# Models that actually have useful information in them	my @havenotsData = ();	# Models that only contain "$bogusHit" for values		foreach $topModel (@{$theOrder}) {		my $hit = 0;		foreach $secModel (@{$theOrder}) {			next if ($topModel eq $secModel);			if ($val{$topModel}{$secModel} != $bogusHit) {				$hit = 1;				last;			}		}		if ($hit != 0) {			push @havesData, $topModel;		} else {			push @havenotsData, $topModel;		}	}		open (FILE, ">$HOME/RCstats") or die "STATOUT: Failure to write to $HOME/RCstats: $!\n";	foreach $topModel (@havesData) {		print FILE "$topModel\t";		foreach $secModel (@havesData) {			print FILE "$val{$topModel}{$secModel}\t";		}		print FILE "\n";	}	close FILE;		print "<FONT COLOR=green>Data written to file RCstats\n";	my $t = time;	my $dummyOut = (`/usr/local/etc/httpd/cgi-bin/pagelab/wu_data/src/rand_cost < $HOME/RCstats > $HOME/RCneighbors`);	$t = time - $t;	print ", and models ordered by random cost algorithm in $t seconds.</FONT><BR>\n";		&LOADNEIGHBORS;	for my $y (0..$#neighbors) {		my $topModel = $neighbors[$y];		for my $x (0..$#neighbors) {			my $secModel = $neighbors[$x];			if ($HitCount{$topModel}{$secModel} != 0) {				my $hits	= $HitCount{$topModel}{$secModel};				my $avgLod	= $lodSum1{$topModel}{$secModel} / $hits;				my $avgDst	= $distSum1{$topModel}{$secModel} / $hits;				my $devIn	= $avgLod*$avgLod - 2 * $avgLod *  $lodSum1{$topModel}{$secModel} / $hits + $lodSum2{$topModel}{$secModel} / $hits;				my $devLod	= sqrt(int(0.5 + 1000000*$devIn)/1000000);				my $devIn	= $avgDst*$avgDst - 2 * $avgDst * $distSum1{$topModel}{$secModel} / $hits + $distSum2{$topModel}{$secModel} / $hits;				my $devDist	= sqrt(int(0.5 + 1000000*$devIn)/1000000);				$AverageLODs{$topModel}{$secModel}		= $avgLod;				$AverageDist{$topModel}{$secModel}		= $avgDst;				$AverageLODsSD{$topModel}{$secModel}	= $devLod;				$AverageDistSD{$topModel}{$secModel}	= $devDist;			} else {				$AverageLODs{$topModel}{$secModel}		= "";				$AverageDist{$topModel}{$secModel}		= "";				$AverageLODsSD{$topModel}{$secModel}	= "";				$AverageDistSD{$topModel}{$secModel}	= "";			}		}	}	print "<FONT COLOR=green>Average values and standard deviations calculated for LODs and distances\n";	my @Variables = ("AverageLODs", "AverageDist", "AverageLODsSD", "AverageDistSD");	open (FILE, ">$HOME/StatisticTables") or die "STATOUT: Failure to write to $HOME/StatisticTables: $!\n";	foreach my $v (@Variables) {		print FILE "Variable\t$v\nOrder";		for my $x (0..$#neighbors) {			print FILE "\t$neighbors[$x]";		}		print FILE "\n";		for my $y (0..$#neighbors) {			my $topModel = $neighbors[$y];			print FILE "$topModel";			for my $x (0..$#neighbors) {				my $secModel = $neighbors[$x];				my $val = ${$v}{$topModel}{$secModel};				if ($val ne "") {					printf FILE ("\t%.2f", ${$v}{$topModel}{$secModel});				} else {					print FILE "\t";				}			}			print FILE "\n";		}		print FILE "\n";	}	close FILE;	print ", and written to file StatisticTables.</FONT><BR>\n";	&DRAWAVGLOD;	$statTime = time - $statTime;	print "<FONT COLOR=brown>Total time devoted to statistics calculation and display was $statTime seconds.</FONT>\n";	}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub LOADSTATS {	open (FILE, "$HOME/StatisticTables") or die "STATOUT: Failure to load $HOME/StatisticTables: $!\n";	my $theVar = "";			# The current variable being considered.	my @theOrder = ();			# The order of models for the variable	while (<FILE>) {		chomp;		next if ($_ eq "");		my @t = split "\t", $_;		if ($t[0] eq "Variable") {			$theVar = $t[1];			%{$theVar} = ();			next;		}		if ($t[0] eq "Order") {			$dum = shift @t;			@theOrder = @t;			next;		}		my $topModel = shift @t;		for $y (0..$#theOrder) {			${$theVar}{$topModel}{$theOrder[$y]} = $t[$y];		}	}	close FILE;	print "<FONT COLOR=green>All model statistics succefully loaded.<BR>\n";}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub LOADNEIGHBORS {	@neighbors = @origNeighbors = (); my %NeighAdd = ();	open (FILE, "$HOME/RCneighbors") or die "STATOUT: Failure to read $HOME/RCneighbors: $!\n";	while (<FILE>) {		chomp;		next if ($_ eq "");		my $mod = $_;		my $l = length($mod);		$mod = substr($mod,0,$l-1) if (($l+1) % 2 != 0);	# The first model is being trashed for some reason... an extra odd character is being added to the name. I think rand_cost is doing this...		push @neighbors, $mod;		push @origNeighbors, $mod;		$NeighAdd{$mod} = 1;	}	foreach $n (@allModels) {			# Add the unsorted neighbors to the end		push @neighbors, $n if ($NeighAdd{$n} != 1);	}	close FILE;}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub DRAWAVGLOD {	my $saveFile	= shift;	# [0] - filename where data should be saved	&LOADNEIGHBORS;	&LOADSTATS;	my $xOrder = \@neighbors;	my $yOrder = \@origNeighbors;	&STATPLOT($yOrder, $xOrder);	for $y (0..$#{$yOrder}) {		$topModel = ${$yOrder}[$y];		my $yl = $y * $hT + $Border;		my $yr = $yl + $hT - 1;		for $x (0..$#{$xOrder}) {			$secModel = ${$xOrder}[$x];			my $xl = $x * $hT + $Border;			my $xr = $xl + $hT - 1;			my $avgLod = $AverageLODs{$topModel}{$secModel};			if ($y == $x) {				$gph->filledRectangle($xl,$yl,$xr,$yr,$white);			} elsif ($avgLod ne "") {				$gph->filledRectangle($xl,$yl,$xr,$yr,$LODcols[ int(0.5 + $avgLod / $stepFactor) ]);			} else {		# No data for this point				$gph->filledRectangle($xl,$yl,$xr,$yr,$ltblue);			}		}	}	close FILE;}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub STATPLOT {	my $yMarkers	= shift;	my $xMarkers	= shift;	$edge			= 30;	$Border			= $wT * $edge;	$height			= $hT * ($#{$yMarkers}+1) + $Border*2;	$width			= $hT * ($#{$xMarkers}+1) + $Border*2;	$gph			= new GD::Image($width+$fudge,$height);	$white			= $gph->colorAllocate(255,255,255);	$black			= $gph->colorAllocate(0,0,0);	$red			= $gph->colorAllocate(255,0,0);	$orange			= $gph->colorAllocate(255,128,0);	$yellow			= $gph->colorAllocate(255,255,0);	$green			= $gph->colorAllocate(0,128,0);	$blue			= $gph->colorAllocate(0,0,255);	$purple			= $gph->colorAllocate(255,0,128);	$ltblue			= $gph->colorAllocate(128,128,255);	$gray			= $gph->colorAllocate(150,150,150);		for my $i (0..$#{$yMarkers}) {		my $n			= ${$yMarkers}[$i];		my $l			= length($n);		my $polarity	= (substr($n,0,1) eq "B") ? 1 : 0;		# Decide if model begins with "A" (0) or "B" (1)		my $y 			= $i * $hT + $Border;		my $x 			= $Border - 2 - $wT * length($n);		for $letter (0..($l-1)) {			my $delta = $letter * $wT;			my $col = $black;			my $c = substr($n, $letter, 1);			$c = substr($n, $l-1-$letter, 1) if ($polarity);	# Read the model backwards			if ($c eq 'B') {				$col = $blue;			} elsif ($c eq '|') {				$col = $red;			} elsif ($c eq '*') {				$col = $green;			}			$gph->string(gdTinyFont,$x+$delta				,$y,$c,$col);			$gph->string(gdTinyFont,$width-$Border+2+$delta	,$y,$c,$col);		}	}	for my $i (0..$#{$xMarkers}) {		my $n			= ${$xMarkers}[$i];		my $l			= length($n);		my $polarity	= (substr($n,0,1) eq "B") ? 1 : 0;		# Decide if model begins with "A" (0) or "B" (1)		my $x			= $i * $hT + $Border;		my $y			= $height - $Border + 2 + $wT * $l;		for $letter (0..($l-1)) {			my $delta = $letter * $wT;			my $col = $black;			my $c = substr($n, $letter, 1);			$c = substr($n, $l-1-$letter, 1) if ($polarity);	# Read the model backwards			if ($c eq 'B') {				$col = $blue;			} elsif ($c eq '|') {				$col = $red;			} elsif ($c eq '*') {				$col = $green;			}			$gph->stringUp(gdTinyFont,$x,$Border-2 - $delta	,$c,$col);			$gph->stringUp(gdTinyFont,$x,$y - $delta		,$c,$col);		}	}	@LODcols = ();	$maxPoor = 3; $stepFactor = 0.1;	for ($p = 0; $p <= ($maxPoor+.01); $p += $stepFactor) {		my $index = int(0.5  + $p / $stepFactor);		$greenComponent = int (0.5 + 255 * $p / $maxPoor);			# Will make a gradient from red to yellow		$newCol[$index] = $gph->colorAllocate(255,$greenComponent,0);		$LODcols[$index] = $newCol[$index];#		print "$index ";	}	$minGray = 3; $maxGray = 50;	for $p ($minGray..$maxGray) {		my $intensity = int (128 - 128 * ($p - $minGray) / ($maxGray - $minGray));#		print "$p = $intensity<BR>";		$grayCol[$p] = $gph->colorAllocate($intensity,$intensity,$intensity);	}	for ($p = $maxPoor + $stepFactor; $p <= 100; $p += $stepFactor) {		my $index = int(0.5  + $p / $stepFactor);		$gind = ($p > $maxGray) ? $maxGray : int(0.5 + $p);#		print "$index ";		$LODcols[$index] = $grayCol[$gind];	}}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub PREDICTSTAT {	my $dataRef		= shift;	# [0] - ref to array holding data	my ($lodBest, $lB, $distBest, $dB, $modelBest) = split "!!", ${$dataRef}[0];	for my $n (1..$#{$dataRef}) {		my ($lod, $l, $dist, $d, $model) = split "!!", ${$dataRef}[$n];		$HitCount{$modelBest}{$model}++;		my $lodDelta = $lod  - $lodBest;		$lodSum1{$modelBest}{$model}	+= $lodDelta;		$lodSum2{$modelBest}{$model}	+= $lodDelta * $lodDelta;		my $distDelta = $dist - $distBest;		$distSum1{$modelBest}{$model}	+= $distDelta;		$distSum2{$modelBest}{$model}	+= $distDelta * $distDelta;	}	}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub PREDICTEND {	my $saveFile	= shift;	# [0] - filename where data should be saved	my $otherStuff	= shift;	# [1] - additional text to append after the STOP argument	open (FILE, ">>$DataLoc/$saveFile") or die "PREDICTEND: Failure to append to $saveFile: $!\n";	print FILE "\n\nSTOP\n";	print FILE "\n$otherStuff\n";	close FILE;		my $theSize = -s "$DataLoc/$saveFile";	$theSize = int (0.5 + 100 * $theSize/(1024*1024))/ 100;	print qq(<FONT COLOR=blue>Data saved to file <A HREF="SimulateRH.cgi?Dump=$saveFile&dum=$$" target=_blank>$saveFile</A>, total size $theSize Mb.</FONT>\n);	print " <FONT COLOR=red SIZE=-1>This is far too big to view. Drag link to desktop to copy it to your hard disk.</FONT>\n" if ($theSize > 10);}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub PREDICTINIT {	my $numComp		= shift;	# [0] - number of comparisons that will be done	my $saveFile	= shift;	# [1] - filename where data should be saved	$pTime 			= $lastTime = time;	$totalVariants = 0; $uniqueVariants = 0;	my $units;	my $runTime = $numComp * $Preferences{avgMarkerSpeed};	if ($runTime > 15) {		my $fin = time + $runTime;		print "<CENTER><FONT COLOR=blue SIZE=+1><B>Simulation run time estimated at ";		&CALCTIME(\$runTime, \$units);		print "$runTime $units.<BR>\n";		if ($units !~ /sec/i) {			print "<TABLE><TR><TD BGCOLOR=yellow WIDTH=300><CENTER>";			print "<FONT COLOR=brick SIZE=+4><B>Please do not disturb</B></FONT></TABLE><BR>\n";			my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($fin);			my @days = ('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday');			my $phase = "am";			if ($hour > 12) { $phase = "pm"; $hour -= 12; }			$min = "0" . $min if ($min < 10);			print "Estimated finish at ${hour}:${min} $phase on $days[$wday]<BR>\n";		}		print "</FONT></CENTER></B>\n";	}	&PREDICTPREP($saveFile);}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub GRIDPLOT {	my $toTest		= shift;	# [0] - ref to array of known vectors that will be tested	$edge			= 12;	$Border			= $wT * $edge;	$height			= $hT * ($#{$toTest}+1) + $Border*2;	$width			= $hT * ($#{$toTest}+1) + $Border*2;	$gph			= new GD::Image($width+$fudge,$height);	$white			= $gph->colorAllocate(255,255,255);	$black			= $gph->colorAllocate(0,0,0);	$red			= $gph->colorAllocate(255,0,0);	$green			= $gph->colorAllocate(0,128,0);	$blue			= $gph->colorAllocate(0,0,255);	$orange			= $gph->colorAllocate(255,128,0);	$purple			= $gph->colorAllocate(255,0,128);	$gray			= $gph->colorAllocate(150,150,150);		open (FILE,"$HOME/Spectrum.gif") || die qq(Can't find "Spectrum.gif": $!\n);	my $spect = newFromGif GD::Image(FILE) || die "Can't generate GIF from Spectrum.gif: $!\n";	close FILE;	@col = ();		$numDivisions = 50;	$colDiv = int ($maxLinkage / $numDivisions);	for $i (0..($numDivisions+1)) {		$index = $spect->getPixel(int(200 * $i/$numDivisions),1);		$col[$i] = $gph->colorAllocate($spect->rgb($index));	}	my $step = 50;	for (my $i=0; $i <= $maxLinkage / $step; $i++) {		my $y = $i * $hT;		my $n = $i * $step;		my $c = $n / $colDiv;		$n = " " . $n . " kb";		$gph->filledRectangle($0,$y,$hT-2,$y+$hT-2,$col[ $c ]);		$gph->string(gdTinyFont,$hT,$y,$n,$black);	}	push @col, $gray; 		%markPos		= ();	for my $i (0..$#{$toTest}) {		my $n			= ${$toTest}[$i];		$markPos{ $n }	= $i;		my $x			= $i * $hT + $Border;		my $y			= $height - $Border + 2 + $wT * length($n);		$gph->stringUp(gdTinyFont,$x,$Border-2	,$n,$black);		$gph->stringUp(gdTinyFont,$x,$y			,$n,$black);		$y 				= $x;		$x 				= $Border - 2 - $wT * length($n);		$gph->string(gdTinyFont,$x				,$y,$n,$black);		$gph->string(gdTinyFont,$width-$Border+2,$y,$n,$black);	}}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub LINKAGETEST {	my $toTest		= shift;	# [0] - ref to array of known vectors that will be tested	my $saveFile	= shift;	# [1] - filename where data should be saved	my $totMark		= $#{$toTest} +1;	my $numMrk = ($totMark - 1) * $totMark / 2;	&PREDICTINIT($numMrk, $saveFile);	my $edge		= 12;	my $Border		= $wT * $edge;	my $height		= $hT * ($#{$toTest}+1) + $Border*2;	my $width		= $hT * ($#{$toTest}+1) + $Border*2;	my $gph			= new GD::Image($width+$fudge,$height);	my $white		= $gph->colorAllocate(255,255,255);	my $black		= $gph->colorAllocate(0,0,0);	my $red			= $gph->colorAllocate(255,0,0);	my $pink		= $gph->colorAllocate(255,128,128);	my $green		= $gph->colorAllocate(0,128,0);	my $blue		= $gph->colorAllocate(0,0,255);	my $purple		= $gph->colorAllocate(255,0,128);	my $gray		= $gph->colorAllocate(150,150,150);	my @linkCols = my @unlinkCols = (); %drawCols = ();	my $maxPoor = 3; my $stepFactor = 0.1;	if ($fancyColor) {		for ($p = 0; $p <= ($maxPoor+.01); $p += $stepFactor) {			my $index = int(0.5  + $p / $stepFactor);			$in = int (0.5 + 128 * $p / $maxPoor);					# Will make an intensity gradient from black to gray			$linkCols[$index]	= $gph->colorAllocate($in,$in,0);	# Gradient from black to yellow			$unlinkCols[$index]	= $gph->colorAllocate($in,0,$in);	# Gradient from black to purple			$drawCols{$index} = $linkCols[$index];			$drawCols{-$index} = $unlinkCols[$index];		}		$minGray = 3; $maxGray = 50;		my @greenScale = my @redScale = ();		for $p ($minGray..$maxGray) {			my $in = int (255 - 128 * ($p - $minGray) / ($maxGray - $minGray));	# Gradient from gray to white			$greenScale[$p]	= $gph->colorAllocate(0,$in,0);						# Gradient from half green to green			$redScale[$p]	= $gph->colorAllocate($in,0,0);						# Gradient from half red to red		}		for ($p = $maxPoor + $stepFactor; $p <= 100; $p += $stepFactor) {			my $index = int(0.5  + $p / $stepFactor);			$gind = ($p > $maxGray) ? $maxGray : int(0.5 + $p);			$drawCols{$index}	= $greenScale[$gind];			$drawCols{-$index}	= $redScale[$gind];		}	} else {		for ($p = 0; $p <= 1.01; $p += $stepFactor) {			my $index = int(0.5  + $p / $stepFactor);			$drawCols{$index}	= $black;			$drawCols{-$index}	= $black;		}		$green1	= $gph->colorAllocate(0,51,0);		$blue1	= $gph->colorAllocate(0,0,51);		for ($p = 1; $p <= 2.01; $p += $stepFactor) {			my $index = int(0.5  + $p / $stepFactor);			$drawCols{$index}	= $green1;			$drawCols{-$index}	= $blue1;		}		$green2	= $gph->colorAllocate(0,153,0);		$blue2	= $gph->colorAllocate(0,0,153);		for ($p = 2; $p <= 3.01; $p += $stepFactor) {			my $index = int(0.5  + $p / $stepFactor);			$drawCols{$index}	= $green2;			$drawCols{-$index}	= $blue2;		}		$green3	= $gph->colorAllocate(0,204,0);		$blue3	= $gph->colorAllocate(0,0,204);		for ($p = 3; $p <= 4.01; $p += $stepFactor) {			my $index = int(0.5  + $p / $stepFactor);			$drawCols{$index}	= $green3;			$drawCols{-$index}	= $blue3;		}		$green4	= $gph->colorAllocate(0,255,0);		$blue4	= $gph->colorAllocate(0,0,255);		for ($p = 4; $p <= 150; $p += $stepFactor) {			my $index = int(0.5  + $p / $stepFactor);			$drawCols{$index}	= $green4;			$drawCols{-$index}	= $blue4;		}	}		my %markPos		= ();	for my $i (0..$#{$toTest}) {		my $n			= ${$toTest}[$i];		$markPos{ $n }	= $i;		my $x			= $i * $hT + $Border;		my $y			= $height - $Border + 2 + $wT * length($n);		$gph->stringUp(gdTinyFont,$x,$Border-2	,$n,$black);		$gph->stringUp(gdTinyFont,$x,$y			,$n,$black);		$y 				= $x;		$x 				= $Border - 2 - $wT * length($n);		$gph->string(gdTinyFont,$x				,$y,$n,$black);		$gph->string(gdTinyFont,$width-$Border+2,$y,$n,$black);	}	# # # # # # # # # #	Cycle down the rows			= $a -> $aMarker	for my $a (0..($#{$toTest} - 1)) {				# Row Number		my $aMarker = ${$toTest}[$a];		my $yl = $a * $hT + $Border;		my $yr = $yl + $hT - 1;		# # # # # # # #	Cycle across the columns	= $b -> $bMarker		for my $b (($a+1)..$#{$toTest}) {			# Column number			my $bMarker = ${$toTest}[$b];			next if ($aMarker eq $bMarker);			my $xl = $b * $hT + $Border;			my $xr = $xl + $hT - 1;			my @Output = ();			my $totTwo = $myVectors{$aMarker} . $myVectors{$bMarker};			my @tmpA = ($totTwo =~ /(2)/g);						# Count the combined number of twos			$totTwo = $#tmpA + 1;			if ($totTwo > $maxAmbig) {						# Too many Ambiguous				$gph->filledRectangle($xl+2,$yl+2,$xr-2,$yr-2,$pink);				$gph->filledRectangle($yl+2,$xl+2,$yr-2,$xr-2,$pink);				next;			}			$tempTime = time;			my ($theLOD, $devLOD) = split "\t", Probability::twoVector($myVectors{$aMarker}, $myVectors{$bMarker});			$fpMainLoopTime += time - $tempTime;			my $index = int($theLOD / $stepFactor);			my $devIn = int($devLOD / $stepFactor);			$gph->filledRectangle($xl,$yl,$xr,$yr,$drawCols{$index});			$gph->filledRectangle($yl,$xl,$yr,$xr,$drawCols{$index});			$gph->filledRectangle($xl+2,$yl+2,$xr-2,$yr-2,$drawCols{$devIn});			$gph->filledRectangle($yl+2,$xl+2,$yr-2,$xr-2,$drawCols{$devIn});		}	}	open (FILE, ">$DataLoc/$saveFile.$$.gif") or die "Failure to write to $saveFile.gif: $!\n";	print FILE $gph->gif;	close FILE;	print qq(<img src="$DataLoc/$saveFile.$$.gif"><BR>\n);	&PREDICTTERM($numMrk, $saveFile);}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub GRIDPREDICT {	my $toTest		= shift;	# [0] - ref to array of known vectors that will be tested	my $saveFile	= shift;	# [1] - filename where data should be saved	my $totMark		= $#{$toTest} +1;	my $numMrk = ($totMark - 1) * $totMark / 2;	&PREDICTINIT($numMrk, $saveFile);	&GRIDPLOT($toTest);	my $gridLimit		= 100;	my $tagTime			= 60 * 5;	my %copyNumber		= %copyEvnts = ();	if ($totMark > $gridLimit) {		print "<FONT COLOR=darkgreen>A table is only drawn for less than $gridLimit markers. \n";		print "Check the save file to retrieve your data.</FONT><BR>\n";		print "<PRE>";	} elsif ($linkStats) {		print "<FONT COLOR=darkgreen>You have requested statistics only, a marker table will not be drawn.</FONT><BR>\n";		print "<PRE>";	} else {		print "<PRE>";		print "<TABLE BORDER=1><TR><TD>";		for my $b (1..$#{$toTest}) {			# Column number			print "<TH>${$toTest}[$b]";		}		print "<TD><TH>Copies\n";	}	# # # # # # # # # #	Cycle down the rows			= $a -> $aMarker	for my $a (0..($#{$toTest} - 1)) {		my $aMarker = ${$toTest}[$a];		unless ($totMark > $gridLimit || $linkStats) {			print "<TR><TH>$aMarker\n";				print "<TD COLSPAN=$a>" if ($a > 0);	# Pad the appropriate number of columns as you move down the rows		} elsif (time - $lastTime > $tagTime) {		# For longer runs add time tags to help track the data			open (FILE, ">>$DataLoc/$saveFile") or die "PREDICTEND: Failure to append time mark in $saveFile: $!\n";			my $tp = time - $pTime;			&CALCTIME(\$tp, \$units);			print FILE "Time Point\t$pTime\t= $tp $units\n";			close FILE;				print "$tp $units\n";			$lastTime = time;		}		# # # # # # # #	Cycle across the columns	= $b -> $bMarker		for my $b (($a+1)..$#{$toTest}) {			# Column number			unless ($totMark > $gridLimit || $linkStats) {				print "<TD>";			}			my $bMarker = ${$toTest}[$b];			my @Output = ();			my $totTwo = $myVectors{$aMarker} . $myVectors{$bMarker};			my @tmpA = ($totTwo =~ /(2)/g);						# Count the combined number of twos			$totTwo = $#tmpA + 1;			if ($totTwo > $maxAmbig) {							# Too many Ambiguous				print "<FONT COLOR=purple>Combined ambiguous results of $totTwo.</FONT>\n" unless ($totMark > $gridLimit || $linkStats);				next;			}	#		&PREDICT($aMarker,$bMarker, \@Output, $saveFile);			&FASTPREDICT($aMarker,$bMarker, \@Output, $saveFile);			($bestScore) = split "\t", $Output[0];			my $avDist = 0; my $avNum = 0;			foreach $j (@Output) {				my @d = split "!!", $j;				if ($d[0] - $bestScore <= $lodCutoff) {					my @tmpA = ($d[4] =~ /(A)/g);				# Count the number of As					$copyNumber{$aMarker}[$#tmpA+1]++;					$copyEvnts{$aMarker}++;					my @tmpB = ($d[4] =~ /(B)/g);				# Count the number of Bs					$copyNumber{$bMarker}[$#tmpB+1]++;					$copyEvnts{$bMarker}++;					my $dist = $d[2];					$dist = 1000 if ($dist =~ /unl/i);					$avDist += $dist; $avNum++;				}			}			&GRIDCELL(\@Output) unless ($totMark > $gridLimit || $linkStats);#			$avDist = $avDist/ $avNum;#			if ($avDist > $maxLinkage) {#				$avDist = $#col;#			} else {#				$avDist = $avDist/ $colDiv;#			}#			my $x = $Border + $markPos{ $bMarker } * $hT;#			my $y = $Border + $markPos{ $aMarker } * $hT;#			$gph->filledRectangle($x,$y,$x+$hT-2,$y+$hT-2,$col[ $avDist ]);#			$gph->filledRectangle($y,$x,$y+$hT-2,$x+$hT-2,$col[ $avDist ]);		}		unless ($totMark > $gridLimit || $linkStats) {			print "<TH>$aMarker\n";				if ($a == 0) {				print "<TD><PRE>";					# The first marker does not have a column, so copy number must be tacked on to the end				for my $cn (0..$#{$copyNumber{$aMarker}}) {					next if ($copyNumber{$aMarker}[$cn] <= 0);					print $cn + 1;					my $p = int (100 * $copyNumber{$aMarker}[$cn] / $copyEvnts{$aMarker});					print ": $p%\n";				}			}		}	}	unless ($totMark > $gridLimit || $linkStats) {		print "<TR><TD>";		for my $b (1..$#{$toTest}) {			# Column number			print "<TH>${$toTest}[$b]";		}		print "<TR><TH>Copies:\n";	}	for my $b (1..$#{$toTest}) {	# Column number		my $mrk = ${$toTest}[$b];		print "<TD><PRE>" unless ($totMark > $gridLimit || $linkStats);		for my $cn (0..$#{$copyNumber{$mrk}}) {			$copyNumber{$mrk}[$cn] = int (0.5 + 100 * $copyNumber{$mrk}[$cn] / $copyEvnts{$mrk});			next if ($copyNumber{$mrk}[$cn] <= 0);			print $cn unless ($totMark > $gridLimit || $linkStats);			print ": $copyNumber{$mrk}[$cn]%\n" unless ($totMark > $gridLimit || $linkStats);		}	}	open (FILE, ">>$DataLoc/$saveFile") or die "GRIDPREDICT: Failure to append to $saveFile: $!\n";	for my $b (0..$#{$toTest}) {	# Column number		my $mrk = ${$toTest}[$b];		print FILE "Copy\t$mrk";		for my $cn (0..$#{$copyNumber{$mrk}}) {			print FILE "\t$copyNumber{$mrk}[$cn]";		}		print FILE "\n";	}	close FILE;		print "</TABLE>" unless ($totMark > $gridLimit || $linkStats);	print "</PRE>";	&PREDICTTERM($numMrk, $saveFile);	if ($linkStats) {		&STATOUT($saveFile);	} else {		&PREDICTEND($saveFile, $timeOut);	}		open (FILE, ">$DataLoc/$saveFile.$$.gif") or die "Failure to write to $saveFile.gif: $!\n";	print FILE $gph->gif;	close FILE;	print qq(<img src="$DataLoc/$saveFile.$$.gif"><BR>\n);}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - # Print out the results of a comparison in the cell of a grid searchsub GRIDCELL {	my $outRef		= shift;		# [0] - reference to array holding data	print "<PRE><FONT COLOR=green>";	my $w = 0;	foreach my $n (@{$outRef}) {							# Find maximum length of model text (used for formating output		my @d = split "!!", $n;		$w = length($d[4]) if (length($d[4]) > $w);	}	my $unlCol = "black";	for my $j (0..$#{$outRef}) {		my @d = split "!!", ${$outRef}[$j];		if ($d[0] - $bestScore > $lodCutoff) {			print "<FONT COLOR=red>";			$unlCol = "gray";		} else {			print "<FONT COLOR=blue>" if ($j == 1);		}		if ($d[2] =~ /unl/i) {			printf("<FONT COLOR=$unlCol>%${w}.${w}s %5.1f Unlnk</FONT>", $d[4], $d[0]);		} else {			printf("%${w}.${w}s %5.1f %3.fkb", $d[4], $d[0], $d[2]);		}		print "\n" if ($j != $#{$outRef});	}}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub NEIGHBORPREDICT {	my $toTest		= shift;	# [0] - ref to array of known vectors that will be tested	my $saveFile	= shift;	# [1] - filename where data should be saved	&PREDICTINIT($#{$toTest}, $saveFile);	if ($linkStats) {		print "<PRE>";	} else {		print "<TABLE BORDER=1><TR><TH>Marker Pair<TD><PRE>";		printf("%20.20s  %10.10s at %10.10s kb", "Model", "log Probability", "Distance");		print "<TH>Status";	}#	print "</TABLE>";	undef(@copyProb);	for $c (1..$maxCopyNum) {		$probPos = 1 - Probability::simplePower((1-$RF/100), $c);		for $k (0..$numHybrids) {			my $p = Probability::simplePower($probPos, $k) * Probability::simplePower(1 - $probPos, $numHybrids - $k);			$p *= &NCHOOSEK($numHybrids, $k);			$copyProb[$c][$k] = -log($p) / log(10);#			print "$copyProb[$c][$k]\t";		}		print "<TH>$c";#		print "<BR>";	}	for my $i (1..$#{$toTest}) {		my $aMarker = ${$toTest}[$i-1];		my $bMarker = ${$toTest}[$i];		print "<TR><TD>$aMarker <FONT COLOR=lightblue>vs.</FONT> $bMarker\n<TD>" unless ($linkStats);		my $totTwo = $myVectors{$aMarker} . $myVectors{$bMarker};		my @tmpA = ($totTwo =~ /(2)/g);						# Count the combined number of twos		$totTwo = $#tmpA + 1;		if ($totTwo > $maxAmbig) {							# Too many Ambiguous			print "<FONT COLOR=purple>Combined ambiguous results of $totTwo.</FONT>\n" unless ($linkStats);			next;		}		my @Output = ();#		&PREDICT($aMarker,$bMarker, \@Output, $saveFile);		&FASTPREDICT($aMarker,$bMarker, \@Output, $saveFile);		next if ($linkStats);		print "<PRE><FONT COLOR=green>";		my ($bestScore,$d1,$d2,$d3,$bestMod) = split "!!", $Output[0];#		print ">> $bestMod";		my $unlCol = "black";		my $delta = 0;		my $state = "Unlinked";		if ($bestMod =~ /\*/) {			$state = "Linked";		}		for my $j (0..$#Output) {			@d = split "!!", $Output[$j];			if ($d[0] - $bestScore > $lodCutoff) {				print "<FONT COLOR=red>";				$unlCol = "gray";			} elsif ($j == 1) {				print "<FONT COLOR=blue>";			}			if ($d[4] !~ /\*/) {				printf("<FONT COLOR=$unlCol>%30.30s  %5.2f  %4.2f %16.16s</FONT>", $d[4], $d[0], $d[1], "Unlinked Model");				$delta = $d[0] - $bestScore if ($state eq "Linked" && $delta == 0);			} else {				printf("%30.30s  %5.2f  %4.2f at %4.0f  %3.0f kb", $d[4], $d[0], $d[1], $d[2], $d[3] );				$delta = $d[0] - $bestScore if ($state eq "Unlinked" && $delta == 0);			}			print "\n" if ($j != $#Output);		}		print "<TD>";		if ($delta && $delta < $lodCutoff) {			my $col = ($state eq "Linked" ? "LIME" : "PINK");			printf("<FONT COLOR=$col>%s %.2f\n", $state, $delta);		} else {			my $col = ($state eq "Linked" ? "GREEN" : "RED");			print "<FONT COLOR=$col><B>$state</B>";					}				my $vec = $myVectors{$aMarker};		my @tmp2 = ($vec =~ /(2)/g);						# Count the number of twos		my @tmp1 = ($vec =~ /(1)/g);						# Count the number of ones		my $hits = int( ($#tmp1 + 1) + ($#tmp2 + 1)/2);				my @cop;		my $min = 9999999;		for $c (1..$maxCopyNum) {			$cop[$c] = $copyProb[$c][$hits];			$min = $cop[$c] if ($min > $cop[$c]);		}		for $c (1..$maxCopyNum) {			if (abs($min - $cop[$c]) < 3) {				print "<TD BGCOLOR=yellow><FONT COLOR=green><B>";			} else {				print "<TD><FONT COLOR=gray>";			}			printf("%.2f", $cop[$c]);		}				print "\n";	}	print "</TABLE>\n";	&PREDICTTERM($#{$toTest}, $saveFile);	&STATOUT ($saveFile) if ($linkStats);}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub PREDICTTERM {	my $numComp		= shift;	# [0] - number of comparisons that will be done	my $saveFile	= shift;	# [1] - filename where data should be saved	$pTime = time - $pTime;	$pTime = 1 if ($pTime < 1);	my ($rate, $mkSpeed);	my $MLR = int (1000 * $fpMainLoopTime / $pTime)/10;	if ($pTime == 0) {		$rate = "an awful lot of";	} else {		$Preferences{modelRate}			= $rate		= $uniqueVariants * $numSubModels / $pTime;		$rate		= int (0.5 + $rate);		$Preferences{avgMarkerSpeed}	= $mkSpeed	= $pTime / $numComp;		$mkSpeed	= int (100 * $mkSpeed) / 100;		&WRITEPREF;	}	&CALCTIME(\$pTime, \$units);	print "<BR><FONT COLOR=BROWN><i>";	$timeOut = "$totalVariants ambiguity variants distilled to $uniqueVariants unique patterns. ";	$timeOut .= "The average speed was $mkSpeed seconds per marker.<BR>\n";	$timeOut .= "$numSubModels statistical sub-models (in $numModels models) were analyzed in $pTime $units ";	$timeOut .= "for a rate of $rate submodel-variants per second.<BR>\n";	$timeOut .= "The main probability loop occupied $MLR % of the time.<BR>\n";	print "$timeOut</FONT></i>\n";}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub FASTPREDICT {	my $aMarker		= shift;	# [0] - ref to array of known vectors that will be tested	my $bMarker		= shift;	# [1] - filename where data should be saved	my $outRef		= shift;	# [2] - Reference to array that will hold data	my $saveFile	= shift;	# [3] - filename where data should be saved	$tempTime = time;	@{$outRef} = split "\t", Probability::twoVector($myVectors{$aMarker}, $myVectors{$bMarker});	$fpMainLoopTime += time - $tempTime;	if ($linkStats) {		&PREDICTSTAT( $outRef);	} else {		&PREDICTADD($saveFile, $aMarker, $bMarker, $outRef);	}}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub PREDICT {	my $aMarker		= shift;	# [0] - ref to array of known vectors that will be tested	my $bMarker		= shift;	# [1] - filename where data should be saved	my $outRef		= shift;	# [2] - Reference to array that will hold data	my $saveFile	= shift;	# [3] - filename where data should be saved	my %Variants = (); my $muchAmbig = 0;	my $tempTime = time;	&PARSEVECTOR( $myVectors{$aMarker},	$myVectors{$bMarker},		\%Variants);	$pvTime += time - $tempTime;	my @varKeys = sort {$a cmp $b} keys %Variants;	$totVars = $#varKeys + 1;								# Global variable - used in a lot of routines	$totalVariants	+= $totVars;	$tempTime = time;	$uniqueVariants	+= &FINDPROB(\%Variants, $outRef);	$fpTime += time - $tempTime;	&PREDICTADD($saveFile, $aMarker, $bMarker, $outRef);}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub WRITEPREF {	open (FILE, ">$DataLoc/Preferences") or die "Failure to write Preferences file: $!\n";	foreach my $k (keys %Preferences) {		print FILE "$k\t$Preferences{$k}\n";	}	close FILE;}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub READPREF {	print "<!"; my $checkPrf = `ls $DataLoc/Preferences`;	chomp $checkPrf; print ">";	unless ($checkPrf eq "") {		open (FILE, "$DataLoc/Preferences") or die "Failure to write Preferences file: $!\n";		while (<FILE>) {			my @t = split "\t";			$Preferences{$t[0]} = $t[1];		}		close FILE;	}	$Preferences{avgMarkerSpeed}	= 0.2 unless ($Preferences{avgMarkerSpeed});}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - # [0] - Simple string holding first vector# [1] - Simple string holding second vector# [2] - ref to array that will hold resultssub PARSEVECTOR {	my $VectorA	= shift;	my $VectorB	= shift;	my $output	= shift;	my @code	= ();	my @ambigs	= ();	my $NT		= $nullToken;	my @assaysA = split '', $VectorA;	my @assaysB = split '', $VectorB;	$code[0][0]	= "$NT$NT";	$code[1][0]	= "A$NT";	$code[0][1]	= "B$NT";	$code[1][1]	= "AB";	@allPossible		= ( "$NT$NT", "A$NT", "B$NT", "AB");	@{$ambigs[2][2]}	= @allPossible;	@{$ambigs[1][2]}	= ( "A$NT", "AB");	@{$ambigs[2][1]}	= ( "B$NT", "AB");	@{$ambigs[0][2]}	= ( "$NT$NT", "B$NT");	@{$ambigs[2][0]}	= ( "$NT$NT", "A$NT");	if ($#assaysA != $#assaysB) {		print qq(<PRE><FONT COLOR=red>Error - Attempt to compare two vectors with different length:</FONT><BR>\n);		print "<FONT COLOR=BLUE>Vector A:$VectorA\nVector B:$VectorB</PRE></FONT>\n";		return;	}	my %unAmb			= ();	my @Ambig			= ();	my @ambigCounter	= ();	my $sum;	for my $i (0..$#assaysA) {		if ($assaysA[$i] == 2 || $assaysB[$i] == 2) {			push @Ambig, [ @{$ambigs[ $assaysA[$i] ][ $assaysB[$i] ]} ];			$ambigCounter[$#Ambig] = 0;		} else {			$unAmb{ $code[ $assaysA[$i] ][ $assaysB[$i] ] }++;		}	}	while ($ambigCounter[$#Ambig+1] == 0) {		my $key = "";		my %variant = ();		for my $i (0..$#Ambig) {			if ($ambigCounter[$i] > $#{$Ambig[$i]}) {				$ambigCounter[$i] = 0;				$ambigCounter[$i+1]++;			}			$key .= $ambigCounter[$i];			$variant{ $Ambig[$i][ $ambigCounter[$i] ] }++;		}		$ambigCounter[0]++;		$key = "key" if ($key eq "");		my $checkSum = 0;		foreach $n (@allPossible) {			next if ( ($sum = $variant{ $n } + $unAmb{ $n }) == 0);			$checkSum += $sum;			${$output}{$key}{$n} = $sum		}		if ($checkSum != $#assaysA + 1) {			print "<FONT COLOR=red>Checksum Error: Calculation of ambiguity variant fails:\n";			foreach $n (keys %unAmb) {				print "  $n: ${$output}{$key}{$n} = $variant{ $n } + $unAmb{ $n }\n";			}			print "</FONT>";		}	}}# + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - sub XYPLOT {	my $label		= shift;					# [0] - ref to array of text to use as chart label	my $Yref		= shift;					# [1] - ref to array of (refs of hash of values)	my $Xref		= shift;					# [2] - ref to array of X values	my $width		= shift;					# [3] - width	my $height		= shift;					# [4] - height	my $fileName	= shift;					# [5] - filename base	$fileName		.= int (1000 * rand(1));						# Needed to prevent browser caching	my $right		= $wT*4	+ 5;	my $left		= $wT*4	+ 5;	my $bottom		= $hT*4	+ 5;	my $top			= 5;	my $tickSize	= 3;	my $gph			= new GD::Image($width + $left+$right,$height+$bottom+$top);	my $white		= $gph->colorAllocate(255,255,255);	my $black		= $gph->colorAllocate(0,0,0);	my $red			= $gph->colorAllocate(255,0,0);	my $green		= $gph->colorAllocate(0,128,0);	my $blue		= $gph->colorAllocate(0,0,255);	my $orange		= $gph->colorAllocate(255,128,0);	my $purple		= $gph->colorAllocate(255,0,128);	my $gray		= $gph->colorAllocate(150,150,150);	$gph->transparent($white);	$gph->interlaced('true');	my @Xdata 		= @{$Xref};	my $xmin		= $Xdata[0];	my $xmax		= $Xdata[$#Xdata];	my @Ydata		= ();	my @allKeys		= (); my %inKeys = ();	for my $s (0..$#{$Yref}) {		foreach my $n (keys %{${$Yref}[$s]}) {			next if ($#{$Yref} > 0 && $n eq "$NT$NT");				# Don't include double negatives in multiple plots			unless (exists $inKeys{$n}) {				push @allKeys, $n;				$inKeys{$n} = 1;			}			for my $e (0..$#{${$Yref}[$s]{$n}}) {				$Ydata[$s]{$n}[$e] = ${$Yref}[$s]{$n}[$e];			}		}	}	my %keyCols		= ();	my $counter		= 0;	my $dum			= "";	my @nt			= (1,2,5,10);									# "pleasing" multiples for tick labeling	my $ymin		= 100;	my $ymax		= 0;	my $NT			= $nullToken;	my @Ykeys		= ("A$NT", "B$NT", "AB", "$NT$NT", "A$NT & B$NT");	my @cols		= ($blue, $red, $green, $orange, $purple);	######## Set up Left Y axis ########	foreach my $n (@Ykeys) {		$keyCols{$n} = $cols[$counter++];		next if ($n eq "$NT$NT");		$dum .= " $n";		for my $s (0..$#Ydata) {			next unless (exists $Ydata[$s]{$n});			for my $i (0..$#{$Ydata[$s]{$n}}) {				$Ydata[$s]{$n}[$i] *= 100;				$ymin = $Ydata[$s]{$n}[$i] if ($ymin > $Ydata[$s]{$n}[$i]);				$ymax = $Ydata[$s]{$n}[$i] if ($ymax < $Ydata[$s]{$n}[$i]);			}		}	}	my $maxTick		= $height / ($hT+2);							# The maximum number of y-axis values that can legibily be displayed	my $tickStep	= int (($ymax-$ymin) / $maxTick)+1;				# The spacing that such ticks would have	my $factor 		= 0.01;			my $z = 0;	while ($nt[$#nt] * $factor < $tickStep) { $factor *= 10; }		# Find the order of magnitude that encompases the tickstep	while ($nt[$z]   * $factor < $tickStep) { $z++;}				# Find the appropriate "nicetick" that suits tickstep	my $stepFactor = $nt[$z] * $factor;	$ymin = $stepFactor * int ($ymin / $stepFactor);	my $yRat = $height / ($ymax-$ymin);	my ($x, $y);	for (my $k = $ymin; $k <= $ymax; $k += $stepFactor) {		$y = $height + $top - ($k-$ymin) * $yRat;		$gph->line($left-$tickSize,$y,$left-1,$y,$black);		$gph->string(gdTinyFont,$left-$tickSize-1-$wT*length($k),$y-$hT/2,$k,$black);	}	$gph->line($left-1,$top,$left-1,$height+$top,$black);	$axisLabel = "Probability (%)";	$axisY = $top + ($height+$wT*length($axisLabel.$dum))/2;	$gph->stringUp(gdTinyFont,0,$axisY,$axisLabel,$black);	$axisY -= $wT*length($axisLabel);	foreach my $n (@allKeys) {		next if ($n eq "$NT$NT");		$gph->stringUp(gdTinyFont,0,$axisY," $n",$keyCols{$n});		$thisYmin{$n} = $ymin;		$thisYrat{$n} = $yRat;		$axisY -= $wT*length(" $n");	}	if ($#Ydata == 0) {		######## Set up Right Y axis ########		$ymin		= 100;		$ymax		= 0;		for my $s (0..$#Ydata) {			next unless (exists $Ydata[$s]{"$NT$NT"});			for my $i (0..$#{$Ydata[$s]{"$NT$NT"}}) {				$Ydata[$s]{"$NT$NT"}[$i] *= 100;				$ymin = $Ydata[$s]{"$NT$NT"}[$i] if ($ymin > $Ydata[$s]{"$NT$NT"}[$i]);				$ymax = $Ydata[$s]{"$NT$NT"}[$i] if ($ymax < $Ydata[$s]{"$NT$NT"}[$i]);			}		}		if ($ymin == $ymax) {			$ymin--; $ymax++;		}		$thisYmin{"$NT$NT"} = $ymin;		$maxTick		= $height / ($hT+2);							# The maximum number of y-axis values that can legibily be displayed		$tickStep		= int (($ymax-$ymin) / $maxTick)+1;				# The spacing that such ticks would have		$factor 		= 0.01;			my $z = 0;		while ($nt[$#nt] * $factor < $tickStep) { $factor *= 10; }		# Find the order of magnitude that encompases the tickstep		while ($nt[$z]   * $factor < $tickStep) { $z++;}				# Find the appropriate "nicetick" that suits tickstep		$stepFactor = $nt[$z] * $factor;		$ymin = $stepFactor * int ($ymin / $stepFactor);		$thisYrat{"$NT$NT"} = $height / ($ymax-$ymin);		my ($x, $y);		for (my $k = $ymin; $k <= $ymax; $k += $stepFactor) {			$y = $height + $top - ($k-$ymin) * $thisYrat{"$NT$NT"};			$gph->line($left+$width+1,$y,$left+$width+1+$tickSize,$y,$black);			$gph->string(gdTinyFont,$left+$width+1+$tickSize+1,$y-$hT/2,$k,$black);		}		$gph->line($left+$width+1,$top,$left+$width+1,$height+$top,$black);		$axisLabel = "Probability (%)";		$axisY = $top + ($height+$wT*length($axisLabel." $NT$NT"))/2;		$gph->stringUp(gdTinyFont,$width+$left+$right-$hT,$axisY,$axisLabel,$black);		$axisY -= $wT*length($axisLabel);		$gph->stringUp(gdTinyFont,$width+$left+$right-$hT,$axisY," $NT$NT",$keyCols{"$NT$NT"});	}		######## Set up X axis ########	my $xRat;	my @tags = ('a','b','c','d','e','f','g','h','i','j','k','l','m','n');	if ($#Xdata == 0) {		$axisLabel = "Probabilty Invariant";		$yLabel = $top+$height+$hT;		$Xdata[1] = 1; $Xdata[0] = 0;		for my $s (0..$#Ydata) {			foreach my $n (keys %{$Ydata[$s]}) {				$Ydata[$s]{$n}[1] = $Ydata[$s]{$n}[0];			}		}		$xRat = $width;	} else {		$maxTick		= $width / ($hT+2);								# The maximum number of x-axis values that can legibily be displayed		$tickStep		= int (($xmax-$xmin) / $maxTick)+1;				# The spacing that such ticks would have		$factor 		= 1;			$z = 0;		while ($nt[$#nt] * $factor < $tickStep) { $factor *= 10; }		# Find the order of magnitude that encompases the tickstep		while ($nt[$z]   * $factor < $tickStep) { $z++;}				# Find the appropriate "nicetick" that suits tickstep		$stepFactor = $nt[$z] * $factor;		$xmin = $stepFactor * int ($xmin / $stepFactor);		$xRat = $width / ($xmax-$xmin);		for (my $k = $xmin; $k <= $xmax; $k += $nt[$z] * $factor) {			$x = $left + ($k-$xmin) * $xRat;			$gph->line($x,$height+$top+1,$x,$height+$top+$tickSize,$black);			$gph->stringUp(gdTinyFont,$x-($hT/2),$height+$top+$tickSize+1+ $wT*length($k),$k,$black);		}		$axisLabel = "Variable Distance (kb)";		$yLabel = $top+$bottom+$height-$hT;	}	$gph->string(gdTinyFont,$left + ($width-$wT*length($axisLabel))/2,$yLabel,$axisLabel,$black);	$gph->line($left,$height+1+$top,$width+$left,$height+1+$top,$black);	$counter = 0; my $keyX = $left*2;	my @plotZone = ();	foreach my $n (@allKeys) {#		$gph->string(gdTinyFont,$keyX,$counter,$n,$keyCols{$n});		for my $s (0..$#Ydata) {			next unless (exists $Ydata[$s]{$n});			my $lasty = $height + $top	- ($Ydata[$s]{$n}[0]	- $thisYmin{$n}) * $thisYrat{$n} + $s;			my $lastx = $left			+ ($Xdata[0]		- $xmin) * $xRat;			for my $i (0..$#{$Yd